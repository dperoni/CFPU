AMDAPPSDKROOT=/opt/AMDAPPSDK-3.0
BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:progcomp:promptvars:sourcepath
BASH_ALIASES=()
BASH_ARGC=()
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_COMPAT_DIR=/etc/bash_completion.d
BASH_LINENO=()
BASH_REMATCH=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="4" [1]="3" [2]="11" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
BASH_VERSION='4.3.11(1)-release'
CLUTTER_IM_MODULE=xim
COLORTERM=gnome-terminal
COLUMNS=119
COMPIZ_BIN_PATH=/usr/bin/
COMPIZ_CONFIG_PROFILE=ubuntu
COMP_WORDBREAKS=$' \t\n"\'><=;|&(:'
DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-YY41SoFpRl
DEFAULTS_PATH=/usr/share/gconf/ubuntu.default.path
DESKTOP_SESSION=ubuntu
DIRSTACK=()
DISPLAY=:0
EUID=1000
GDMSESSION=ubuntu
GDM_LANG=en_US
GNOME_DESKTOP_SESSION_ID=this-is-deprecated
GNOME_KEYRING_CONTROL=/run/user/1000/keyring-deg91a
GNOME_KEYRING_PID=2043
GPG_AGENT_INFO=/run/user/1000/keyring-deg91a/gpg:0:1
GROUPS=()
GTK_IM_MODULE=ibus
GTK_MODULES=overlay-scrollbar:unity-gtk-module
HISTCONTROL=ignoreboth
HISTFILE=/home/dperoni/.bash_history
HISTFILESIZE=2000
HISTSIZE=1000
HOME=/home/dperoni
HOSTNAME=ubuntu
HOSTTYPE=x86_64
IFS=$' \t\n'
IM_CONFIG_PHASE=1
INSTANCE=
JOB=dbus
LANG=en_US.UTF-8
LANGUAGE=en_US
LESSCLOSE='/usr/bin/lesspipe %s %s'
LESSOPEN='| /usr/bin/lesspipe %s'
LINES=47
LOGNAME=dperoni
LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:'
M2S_OPENCL_BINARY=/home/dperoni/rodinia_3.1/opencl/nn/nearestNeighbor_kernel.bin
MACHTYPE=x86_64-pc-linux-gnu
MAILCHECK=60
MANDATORY_PATH=/usr/share/gconf/ubuntu.mandatory.path
OLDPWD=/home/dperoni/rodinia_3.1/opencl/nn/tested-data
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/dperoni/RPdev/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin:/home/dperoni/.
PIPESTATUS=([0]="0")
PPID=2679
PS1='\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
PS2='> '
PS4='+ '
PWD=/home/dperoni/rodinia_3.1/opencl/nn
QT4_IM_MODULE=xim
QT_IM_MODULE=ibus
QT_QPA_PLATFORMTHEME=appmenu-qt5
SELINUX_INIT=YES
SESSION=ubuntu
SESSIONTYPE=gnome-session
SESSION_MANAGER=local/ubuntu:@/tmp/.ICE-unix/2255,unix/ubuntu:/tmp/.ICE-unix/2255
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHLVL=1
SSH_AUTH_SOCK=/run/user/1000/keyring-deg91a/ssh
TERM=xterm
TEXTDOMAIN=im-config
TEXTDOMAINDIR=/usr/share/locale/
UID=1000
UPSTART_SESSION=unix:abstract=/com/ubuntu/upstart-session/1000/2045
USER=dperoni
VTE_VERSION=3409
WINDOWID=62925335
XAUTHORITY=/home/dperoni/.Xauthority
XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/usr/share/upstart/xdg:/etc/xdg
XDG_CURRENT_DESKTOP=Unity
XDG_DATA_DIRS=/usr/share/ubuntu:/usr/share/gnome:/usr/local/share/:/usr/share/
XDG_GREETER_DATA_DIR=/var/lib/lightdm-data/dperoni
XDG_MENU_PREFIX=gnome-
XDG_RUNTIME_DIR=/run/user/1000
XDG_SEAT=seat0
XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0
XDG_SESSION_ID=c2
XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session0
XDG_VTNR=7
XMODIFIERS=@im=ibus
_=set
__git_printf_supports_v=yes
__grub_script_check_program=grub-script-check
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|dpkg*|rpm@(orig|new|save))))'
_xspecs=([freeamp]="!*.@(mp3|og[ag]|pls|m3u)" [cdiff]="!*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma))" [bibtex]="!*.aux" [rgview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [oowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm)" [chromium-browser]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [tex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [zathura]="!*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf)" [netscape]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [acroread]="!*.[pf]df" [makeinfo]="!*.texi*" [kwrite]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [gview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [qiv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg)" [lrunzip]="!*.lrz" [bzcat]="!*.?(t)bz?(2)" [amaya]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [pdftex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [hbpp]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [rpm2cpio]="!*.[rs]pm" [view]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [unxz]="!*.@(?(t)xz|tlz|lzma)" [ly2dvi]="!*.ly" [mozilla]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [modplugplay]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|okta|p[st]m|s[3t]m|ult|umx|wav|xm)" [lzgrep]="!*.@(tlz|lzma)" [pyflakes]="!*.py" [dillo]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [aaxine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [dvipdfmx]="!*.dvi" [advi]="!*.dvi" [ggv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [lzmore]="!*.@(tlz|lzma)" [lzless]="!*.@(tlz|lzma)" [kdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [poedit]="!*.po" [firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [madplay]="!*.mp3" [lbzcat]="!*.?(t)bz?(2)" [lilypond]="!*.ly" [gtranslator]="!*.po" [jadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [sxemacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [epdfview]="!*.pdf" [gpdf]="!*.[pf]df" [kghostview]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [pbzcat]="!*.?(t)bz?(2)" [texi2dvi]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [ps2pdf12]="!*.@(?(e)ps|pdf)" [ee]="!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx)" [lzcat]="!*.@(tlz|lzma)" [lbunzip2]="!*.?(t)bz?(2)" [ps2pdf13]="!*.@(?(e)ps|pdf)" [vim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ps2pdf14]="!*.@(?(e)ps|pdf)" [dvips]="!*.dvi" [lzfgrep]="!*.@(tlz|lzma)" [hbrun]="!*.[Hh][Rr][Bb]" [kbabel]="!*.po" [rview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kaffeine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [xv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps)" [rgvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dvitype]="!*.dvi" [oodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [elinks]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [playmidi]="!*.@(mid?(i)|cmf)" [realplay]="!*.@(rm?(j)|ra?(m)|smi?(l))" [xine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [xpdf]="!*.@(pdf|fdf)?(.@(gz|xz|Z|bz2))" [gqmpeg]="!*.@(mp3|og[ag]|pls|m3u)" [lzegrep]="!*.@(tlz|lzma)" [aviplay]="!*.@(avi|asf|wmv)" [latex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [rvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [bunzip2]="!*.?(t)bz?(2)" [ogg123]="!*.@(og[ag]|m3u|flac|spx)" [ps2pdfwr]="!*.@(?(e)ps|pdf)" [znew]="*.Z" [harbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lokalize]="!*.po" [kate]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xemacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dragon]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [unlzma]="!*.@(tlz|lzma)" [pdflatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [vi]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [mozilla-firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ooimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [gvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [uncompress]="!*.Z" [kid3-qt]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [xanim]="!*.@(mpg|mpeg|avi|mov|qt)" [unpigz]="!*.@(Z|[gGd]z|t[ag]z)" [portecle]="!@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts)" [oocalc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [emacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [fbxine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [lynx]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ps2pdf]="!*.@(?(e)ps|pdf)" [kpdf]="!*.@(?(e)ps|pdf)" [oomath]="!*.@(sxm|smf|mml|odf)" [compress]="*.Z" [iceweasel]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [mpg321]="!*.mp3" [mpg123]="!*.mp3" [zcat]="!*.@(Z|[gGd]z|t[ag]z)" [unzip]="!*.@(zip|[ejsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|do[ct][xm]|p[op]t[mx]|xl[st][xm])" [pbunzip2]="!*.?(t)bz?(2)" [kid3]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [pdfjadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [dvipdf]="!*.dvi" [gharbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [modplug123]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|okta|p[st]m|s[3t]m|ult|umx|wav|xm)" [dvipdfm]="!*.dvi" [oobase]="!*.odb" [texi2html]="!*.texi*" [zipinfo]="!*.@(zip|[ejsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|do[ct][xm]|p[op]t[mx]|xl[st][xm])" [epiphany]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gunzip]="!*.@(Z|[gGd]z|t[ag]z)" [google-chrome]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [okular]="!*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM)?(.?(gz|GZ|bz2|BZ2)))" [slitex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [galeon]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [bzme]="!*.@(zip|z|gz|tgz)" [xfig]="!*.fig" [xzcat]="!*.@(?(t)xz|tlz|lzma)" [timidity]="!*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar)" [dviselect]="!*.dvi" [xdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" )
__all_modules () 
{ 
    while read name; do
        name=${name%% *};
        printf "%s\n" "$name";
    done < <(pulseaudio --dump-modules 2> /dev/null)
}
__cards () 
{ 
    while IFS='	' read idx name _; do
        printf "%s %s\n" "$idx" "$name";
    done < <(pactl list cards short 2> /dev/null)
}
__docker_append_to_completions () 
{ 
    COMPREPLY=(${COMPREPLY[@]/%/"$1"})
}
__docker_complete_capabilities () 
{ 
    COMPREPLY=($( compgen -W "
		ALL
		AUDIT_CONTROL
		AUDIT_WRITE
		AUDIT_READ
		BLOCK_SUSPEND
		CHOWN
		DAC_OVERRIDE
		DAC_READ_SEARCH
		FOWNER
		FSETID
		IPC_LOCK
		IPC_OWNER
		KILL
		LEASE
		LINUX_IMMUTABLE
		MAC_ADMIN
		MAC_OVERRIDE
		MKNOD
		NET_ADMIN
		NET_BIND_SERVICE
		NET_BROADCAST
		NET_RAW
		SETFCAP
		SETGID
		SETPCAP
		SETUID
		SYS_ADMIN
		SYS_BOOT
		SYS_CHROOT
		SYSLOG
		SYS_MODULE
		SYS_NICE
		SYS_PACCT
		SYS_PTRACE
		SYS_RAWIO
		SYS_RESOURCE
		SYS_TIME
		SYS_TTY_CONFIG
		WAKE_ALARM
	" -- "$cur" ))
}
__docker_complete_container_ids () 
{ 
    local containers=($(__docker_q ps -aq));
    COMPREPLY=($(compgen -W "${containers[*]}" -- "$cur"))
}
__docker_complete_container_names () 
{ 
    local containers=($(__docker_q ps -aq --no-trunc));
    local names=($(__docker_q inspect --format '{{.Name}}' "${containers[@]}"));
    names=("${names[@]#/}");
    COMPREPLY=($(compgen -W "${names[*]}" -- "$cur"))
}
__docker_complete_containers () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_containers "$@")" -- "$current"))
}
__docker_complete_containers_all () 
{ 
    __docker_complete_containers "$@" --all
}
__docker_complete_containers_in_network () 
{ 
    local containers=$(__docker_q network inspect -f '{{range $i, $c := .Containers}}{{$i}} {{$c.Name}} {{end}}' "$1");
    COMPREPLY=($(compgen -W "$containers" -- "$cur"))
}
__docker_complete_containers_running () 
{ 
    __docker_complete_containers "$@" --filter status=running
}
__docker_complete_containers_stopped () 
{ 
    __docker_complete_containers "$@" --filter status=exited
}
__docker_complete_containers_unpauseable () 
{ 
    __docker_complete_containers "$@" --filter status=paused
}
__docker_complete_detach-keys () 
{ 
    case "$prev" in 
        --detach-keys)
            case "$cur" in 
                *,)
                    COMPREPLY=($( compgen -W "${cur}ctrl-" -- "$cur" ))
                ;;
                *)
                    COMPREPLY=($( compgen -W "ctrl-" -- "$cur" ))
                ;;
            esac;
            __docker_nospace;
            return
        ;;
    esac;
    return 1
}
__docker_complete_image_repos () 
{ 
    local repos="$(__docker_q images | awk 'NR>1 && $1 != "<none>" { print $1 }')";
    COMPREPLY=($(compgen -W "$repos" -- "$cur"))
}
__docker_complete_image_repos_and_tags () 
{ 
    local reposAndTags="$(__docker_q images | awk 'NR>1 && $1 != "<none>" { print $1; print $1":"$2 }')";
    COMPREPLY=($(compgen -W "$reposAndTags" -- "$cur"));
    __ltrim_colon_completions "$cur"
}
__docker_complete_images () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_images)" -- "$cur"));
    __ltrim_colon_completions "$cur"
}
__docker_complete_isolation () 
{ 
    COMPREPLY=($( compgen -W "default hyperv process" -- "$cur" ))
}
__docker_complete_local_interfaces () 
{ 
    local additional_interface;
    if [ "$1" = "--add" ]; then
        additional_interface="$2";
    fi;
    COMPREPLY=($( compgen -W "$(__docker_local_interfaces) $additional_interface" -- "$cur" ))
}
__docker_complete_log_driver_options () 
{ 
    local key=$(__docker_map_key_of_current_option '--log-opt');
    case "$key" in 
        fluentd-async-connect)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        gelf-address)
            COMPREPLY=($( compgen -W "udp" -S "://" -- "${cur##*=}" ));
            __docker_nospace;
            return
        ;;
        gelf-compression-level)
            COMPREPLY=($( compgen -W "1 2 3 4 5 6 7 8 9" -- "${cur##*=}" ));
            return
        ;;
        gelf-compression-type)
            COMPREPLY=($( compgen -W "gzip none zlib" -- "${cur##*=}" ));
            return
        ;;
        syslog-address)
            COMPREPLY=($( compgen -W "tcp:// tcp+tls:// udp:// unix://" -- "${cur##*=}" ));
            __docker_nospace;
            __ltrim_colon_completions "${cur}";
            return
        ;;
        syslog-facility)
            COMPREPLY=($( compgen -W "
				auth
				authpriv
				cron
				daemon
				ftp
				kern
				local0
				local1
				local2
				local3
				local4
				local5
				local6
				local7
				lpr
				mail
				news
				syslog
				user
				uucp
			" -- "${cur##*=}" ));
            return
        ;;
        syslog-format)
            COMPREPLY=($( compgen -W "rfc3164 rfc5424 rfc5424micro" -- "${cur##*=}" ));
            return
        ;;
        syslog-tls-ca-cert | syslog-tls-cert | syslog-tls-key)
            _filedir;
            return
        ;;
        syslog-tls-skip-verify)
            COMPREPLY=($( compgen -W "true" -- "${cur##*=}" ));
            return
        ;;
        splunk-url)
            COMPREPLY=($( compgen -W "http:// https://" -- "${cur##*=}" ));
            __docker_nospace;
            __ltrim_colon_completions "${cur}";
            return
        ;;
        splunk-gzip | splunk-insecureskipverify | splunk-verify-connection)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        splunk-format)
            COMPREPLY=($( compgen -W "inline json raw" -- "${cur##*=}" ));
            return
        ;;
    esac;
    return 1
}
__docker_complete_log_drivers () 
{ 
    COMPREPLY=($( compgen -W "
		awslogs
		etwlogs
		fluentd
		gcplogs
		gelf
		journald
		json-file
		logentries
		none
		splunk
		syslog
	" -- "$cur" ))
}
__docker_complete_log_levels () 
{ 
    COMPREPLY=($( compgen -W "debug info warn error fatal" -- "$cur" ))
}
__docker_complete_log_options () 
{ 
    local awslogs_options="awslogs-region awslogs-group awslogs-stream";
    local fluentd_options="env fluentd-address fluentd-async-connect fluentd-buffer-limit fluentd-retry-wait fluentd-max-retries labels tag";
    local gcplogs_options="env gcp-log-cmd gcp-project labels";
    local gelf_options="env gelf-address gelf-compression-level gelf-compression-type labels tag";
    local journald_options="env labels tag";
    local json_file_options="env labels max-file max-size";
    local logentries_options="logentries-token";
    local syslog_options="env labels syslog-address syslog-facility syslog-format syslog-tls-ca-cert syslog-tls-cert syslog-tls-key syslog-tls-skip-verify tag";
    local splunk_options="env labels splunk-caname splunk-capath splunk-format splunk-gzip splunk-gzip-level splunk-index splunk-insecureskipverify splunk-source splunk-sourcetype splunk-token splunk-url splunk-verify-connection tag";
    local all_options="$fluentd_options $gcplogs_options $gelf_options $journald_options $logentries_options $json_file_options $syslog_options $splunk_options";
    case $(__docker_value_of_option --log-driver) in 
        '')
            COMPREPLY=($( compgen -W "$all_options" -S = -- "$cur" ))
        ;;
        awslogs)
            COMPREPLY=($( compgen -W "$awslogs_options" -S = -- "$cur" ))
        ;;
        fluentd)
            COMPREPLY=($( compgen -W "$fluentd_options" -S = -- "$cur" ))
        ;;
        gcplogs)
            COMPREPLY=($( compgen -W "$gcplogs_options" -S = -- "$cur" ))
        ;;
        gelf)
            COMPREPLY=($( compgen -W "$gelf_options" -S = -- "$cur" ))
        ;;
        journald)
            COMPREPLY=($( compgen -W "$journald_options" -S = -- "$cur" ))
        ;;
        json-file)
            COMPREPLY=($( compgen -W "$json_file_options" -S = -- "$cur" ))
        ;;
        logentries)
            COMPREPLY=($( compgen -W "$logentries_options" -S = -- "$cur" ))
        ;;
        syslog)
            COMPREPLY=($( compgen -W "$syslog_options" -S = -- "$cur" ))
        ;;
        splunk)
            COMPREPLY=($( compgen -W "$splunk_options" -S = -- "$cur" ))
        ;;
        *)
            return
        ;;
    esac;
    __docker_nospace
}
__docker_complete_networks () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_networks "$@")" -- "$current"))
}
__docker_complete_nodes () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_nodes "$@")" -- "$current"))
}
__docker_complete_nodes_plus_self () 
{ 
    __docker_complete_nodes "$@";
    COMPREPLY+=(self)
}
__docker_complete_plugins_bundled () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_plugins_bundled "$@")" -- "$current"))
}
__docker_complete_plugins_installed () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_plugins_installed "$@")" -- "$current"))
}
__docker_complete_resolved_hostname () 
{ 
    command -v host > /dev/null 2>&1 || return;
    COMPREPLY=($(host 2>/dev/null "${cur%:}" | awk '/has address/ {print $4}'))
}
__docker_complete_restart () 
{ 
    case "$prev" in 
        --restart)
            case "$cur" in 
                on-failure:*)

                ;;
                *)
                    COMPREPLY=($( compgen -W "always no on-failure on-failure: unless-stopped" -- "$cur"))
                ;;
            esac;
            return
        ;;
    esac;
    return 1
}
__docker_complete_runtimes () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_runtimes)" -- "$cur"))
}
__docker_complete_secrets () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_secrets)" -- "$cur"))
}
__docker_complete_services () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_services "$@")" -- "$current"))
}
__docker_complete_signals () 
{ 
    local signals=(SIGCONT SIGHUP SIGINT SIGKILL SIGQUIT SIGSTOP SIGTERM SIGUSR1 SIGUSR2);
    COMPREPLY=($( compgen -W "${signals[*]} ${signals[*]#SIG}" -- "$( echo $cur | tr '[:lower:]' '[:upper:]')" ))
}
__docker_complete_stacks () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_stacks "$@")" -- "$current"))
}
__docker_complete_user_group () 
{ 
    if [[ $cur == *:* ]]; then
        COMPREPLY=($(compgen -g -- "${cur#*:}"));
    else
        COMPREPLY=($(compgen -u -S : -- "$cur"));
        __docker_nospace;
    fi
}
__docker_complete_volumes () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_volumes "$@")" -- "$current"))
}
__docker_containers () 
{ 
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Names}}';
            shift;
        else
            if [ "${DOCKER_COMPLETION_SHOW_CONTAINER_IDS}" = yes ]; then
                format='{{.ID}} {{.Names}}';
            else
                format='{{.Names}}';
            fi;
        fi;
    fi;
    __docker_q ps --format "$format" "$@"
}
__docker_images () 
{ 
    local images_args="";
    case "$DOCKER_COMPLETION_SHOW_IMAGE_IDS" in 
        all)
            images_args="--no-trunc -a"
        ;;
        non-intermediate)
            images_args="--no-trunc"
        ;;
    esac;
    local repo_print_command;
    if [ "${DOCKER_COMPLETION_SHOW_TAGS:-yes}" = "yes" ]; then
        repo_print_command='print $1; print $1":"$2';
    else
        repo_print_command='print $1';
    fi;
    local awk_script;
    case "$DOCKER_COMPLETION_SHOW_IMAGE_IDS" in 
        all | non-intermediate)
            awk_script='NR>1 { print $3; if ($1 != "<none>") { '"$repo_print_command"' } }'
        ;;
        none | *)
            awk_script='NR>1 && $1 != "<none>" { '"$repo_print_command"' }'
        ;;
    esac;
    __docker_q images $images_args | awk "$awk_script" | grep --color=auto -v '<none>$'
}
__docker_is_experimental () 
{ 
    [ "$(__docker_q version -f '{{.Server.Experimental}}')" = "true" ]
}
__docker_local_interfaces () 
{ 
    command -v ip > /dev/null 2>&1 || return;
    ip addr show scope global 2> /dev/null | sed -n 's| \+inet \([0-9.]\+\).* \([^ ]\+\)|\1 \2|p'
}
__docker_map_key_of_current_option () 
{ 
    local glob="$1";
    local key glob_pos;
    if [ "$cur" = "=" ]; then
        key="$prev";
        glob_pos=$((cword - 2));
    else
        if [[ $cur == *=* ]]; then
            key=${cur%=*};
            glob_pos=$((cword - 1));
        else
            if [ "$prev" = "=" ]; then
                key=${words[$cword - 2]};
                glob_pos=$((cword - 3));
            else
                return;
            fi;
        fi;
    fi;
    [ "${words[$glob_pos]}" = "=" ] && ((glob_pos--));
    [[ ${words[$glob_pos]} == @($glob) ]] && echo "$key"
}
__docker_networks () 
{ 
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        else
            if [ "${DOCKER_COMPLETION_SHOW_NETWORK_IDS}" = yes ]; then
                format='{{.ID}} {{.Name}}';
            else
                format='{{.Name}}';
            fi;
        fi;
    fi;
    __docker_q network ls --format "$format" "$@"
}
__docker_nodes () 
{ 
    local fields='$2';
    [ "${DOCKER_COMPLETION_SHOW_NODE_IDS}" = yes ] && fields='$1,$2';
    if [ "$1" = "--id" ]; then
        fields='$1';
        shift;
    else
        if [ "$1" = "--name" ]; then
            fields='$2';
            shift;
        fi;
    fi;
    __docker_q node ls "$@" | tr -d '*' | awk "NR>1 {print $fields}"
}
__docker_nospace () 
{ 
    type compopt &> /dev/null && compopt -o nospace
}
__docker_plugins_bundled () 
{ 
    local type add=() remove=();
    while true; do
        case "$1" in 
            --type)
                type="$2";
                shift 2
            ;;
            --add)
                add+=("$2");
                shift 2
            ;;
            --remove)
                remove+=("$2");
                shift 2
            ;;
            *)
                break
            ;;
        esac;
    done;
    local plugins=($(__docker_q info | sed -n "/^Plugins/,/^[^ ]/s/ $type: //p"));
    for del in "${remove[@]}";
    do
        plugins=(${plugins[@]/$del/});
    done;
    echo "${plugins[@]} ${add[@]}"
}
__docker_plugins_installed () 
{ 
    local fields;
    if [ "$DOCKER_COMPLETION_SHOW_PLUGIN_IDS" = yes ]; then
        fields='$1,$2';
    else
        fields='$2';
    fi;
    __docker_q plugin ls | awk "NR>1 {print $fields}"
}
__docker_pos_first_nonflag () 
{ 
    local argument_flags=$1;
    local counter=$((${subcommand_pos:-${command_pos}} + 1));
    while [ $counter -le $cword ]; do
        if [ -n "$argument_flags" ] && eval "case '${words[$counter]}' in $argument_flags) true ;; *) false ;; esac"; then
            (( counter++ ));
            [ "${words[$counter]}" = "=" ] && (( counter++ ));
        else
            case "${words[$counter]}" in 
                -*)

                ;;
                *)
                    break
                ;;
            esac;
        fi;
        while [ "${words[$counter + 1]}" = "=" ]; do
            counter=$(( counter + 2));
        done;
        (( counter++ ));
    done;
    echo $counter
}
__docker_q () 
{ 
    docker ${host:+-H "$host"} ${config:+--config "$config"} "$@" 2> /dev/null
}
__docker_runtimes () 
{ 
    __docker_q info | sed -n 's/^Runtimes: \(.*\)/\1/p'
}
__docker_secrets () 
{ 
    local fields='$2';
    [ "${DOCKER_COMPLETION_SHOW_SECRET_IDS}" = yes ] && fields='$1,$2';
    __docker_q secret ls | awk "NR>1 {print $fields}"
}
__docker_services () 
{ 
    local fields='$2';
    [ "${DOCKER_COMPLETION_SHOW_SERVICE_IDS}" = yes ] && fields='$1,$2';
    if [ "$1" = "--id" ]; then
        fields='$1';
        shift;
    else
        if [ "$1" = "--name" ]; then
            fields='$2';
            shift;
        fi;
    fi;
    __docker_q service ls "$@" | awk "NR>1 {print $fields}"
}
__docker_stacks () 
{ 
    __docker_q stack ls | awk 'NR>1 {print $1}'
}
__docker_subcommands () 
{ 
    local subcommands="$1";
    local counter=$(($command_pos + 1));
    while [ $counter -lt $cword ]; do
        case "${words[$counter]}" in 
            $(__docker_to_extglob "$subcommands"))
                subcommand_pos=$counter;
                local subcommand=${words[$counter]};
                local completions_func=_docker_${command}_${subcommand};
                declare -F $completions_func > /dev/null && $completions_func;
                return 0
            ;;
        esac;
        (( counter++ ));
    done;
    return 1
}
__docker_to_alternatives () 
{ 
    local parts=($1);
    local IFS='|';
    echo "${parts[*]}"
}
__docker_to_extglob () 
{ 
    local extglob=$( __docker_to_alternatives "$1" );
    echo "@($extglob)"
}
__docker_value_of_option () 
{ 
    local option_extglob=$(__docker_to_extglob "$1");
    local counter=$((command_pos + 1));
    while [ $counter -lt $cword ]; do
        case ${words[$counter]} in 
            $option_extglob)
                echo ${words[$counter + 1]};
                break
            ;;
        esac;
        (( counter++ ));
    done
}
__docker_volumes () 
{ 
    __docker_q volume ls -q "$@"
}
__expand_tilde_by_ref () 
{ 
    if [[ ${!1} == \~* ]]; then
        if [[ ${!1} == */* ]]; then
            eval $1="${!1/%\/*}"/'${!1#*/}';
        else
            eval $1="${!1}";
        fi;
    fi
}
__get_cword_at_cursor_by_ref () 
{ 
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur index=$COMP_POINT lead=${COMP_LINE:0:$COMP_POINT};
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]} ) ]]; then
        cur=$COMP_LINE;
        for ((i = 0; i <= cword; ++i ))
        do
            while [[ ${#cur} -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                cur="${cur:1}";
                ((index--));
            done;
            if [[ $i -lt $cword ]]; then
                local old_size=${#cur};
                cur="${cur#"${words[i]}"}";
                local new_size=${#cur};
                index=$(( index - old_size + new_size ));
            fi;
        done;
        [[ -n $cur && ! -n ${cur//[[:space:]]} ]] && cur=;
        [[ $index -lt 0 ]] && index=0;
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "${cur:0:$index}"
}
__git_ps1 () 
{ 
    local pcmode=no;
    local detached=no;
    local ps1pc_start='\u@\h:\w ';
    local ps1pc_end='\$ ';
    local printf_format=' (%s)';
    case "$#" in 
        2 | 3)
            pcmode=yes;
            ps1pc_start="$1";
            ps1pc_end="$2";
            printf_format="${3:-$printf_format}"
        ;;
        0 | 1)
            printf_format="${1:-$printf_format}"
        ;;
        *)
            return
        ;;
    esac;
    local repo_info rev_parse_exit_code;
    repo_info="$(git rev-parse --git-dir --is-inside-git-dir 		--is-bare-repository --is-inside-work-tree 		--short HEAD 2>/dev/null)";
    rev_parse_exit_code="$?";
    if [ -z "$repo_info" ]; then
        if [ $pcmode = yes ]; then
            PS1="$ps1pc_start$ps1pc_end";
        fi;
        return;
    fi;
    local short_sha;
    if [ "$rev_parse_exit_code" = "0" ]; then
        short_sha="${repo_info##*
}";
        repo_info="${repo_info%
*}";
    fi;
    local inside_worktree="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local bare_repo="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local inside_gitdir="${repo_info##*
}";
    local g="${repo_info%
*}";
    local r="";
    local b="";
    local step="";
    local total="";
    if [ -d "$g/rebase-merge" ]; then
        read b 2> /dev/null < "$g/rebase-merge/head-name";
        read step 2> /dev/null < "$g/rebase-merge/msgnum";
        read total 2> /dev/null < "$g/rebase-merge/end";
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="|REBASE-i";
        else
            r="|REBASE-m";
        fi;
    else
        if [ -d "$g/rebase-apply" ]; then
            read step 2> /dev/null < "$g/rebase-apply/next";
            read total 2> /dev/null < "$g/rebase-apply/last";
            if [ -f "$g/rebase-apply/rebasing" ]; then
                read b 2> /dev/null < "$g/rebase-apply/head-name";
                r="|REBASE";
            else
                if [ -f "$g/rebase-apply/applying" ]; then
                    r="|AM";
                else
                    r="|AM/REBASE";
                fi;
            fi;
        else
            if [ -f "$g/MERGE_HEAD" ]; then
                r="|MERGING";
            else
                if [ -f "$g/CHERRY_PICK_HEAD" ]; then
                    r="|CHERRY-PICKING";
                else
                    if [ -f "$g/REVERT_HEAD" ]; then
                        r="|REVERTING";
                    else
                        if [ -f "$g/BISECT_LOG" ]; then
                            r="|BISECTING";
                        fi;
                    fi;
                fi;
            fi;
        fi;
        if [ -n "$b" ]; then
            :;
        else
            if [ -h "$g/HEAD" ]; then
                b="$(git symbolic-ref HEAD 2>/dev/null)";
            else
                local head="";
                if ! read head 2> /dev/null < "$g/HEAD"; then
                    if [ $pcmode = yes ]; then
                        PS1="$ps1pc_start$ps1pc_end";
                    fi;
                    return;
                fi;
                b="${head#ref: }";
                if [ "$head" = "$b" ]; then
                    detached=yes;
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$short_sha...";
                    b="($b)";
                fi;
            fi;
        fi;
    fi;
    if [ -n "$step" ] && [ -n "$total" ]; then
        r="$r $step/$total";
    fi;
    local w="";
    local i="";
    local s="";
    local u="";
    local c="";
    local p="";
    if [ "true" = "$inside_gitdir" ]; then
        if [ "true" = "$bare_repo" ]; then
            c="BARE:";
        else
            b="GIT_DIR!";
        fi;
    else
        if [ "true" = "$inside_worktree" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                git diff --no-ext-diff --quiet --exit-code || w="*";
                if [ -n "$short_sha" ]; then
                    git diff-index --cached --quiet HEAD -- || i="+";
                else
                    i="#";
                fi;
            fi;
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && [ -r "$g/refs/stash" ]; then
                s="$";
            fi;
            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && git ls-files --others --exclude-standard --error-unmatch -- '*' > /dev/null 2> /dev/null; then
                u="%${ZSH_VERSION+%}";
            fi;
            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                __git_ps1_show_upstream;
            fi;
        fi;
    fi;
    local z="${GIT_PS1_STATESEPARATOR-" "}";
    if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
        __git_ps1_colorize_gitstring;
    fi;
    local f="$w$i$s$u";
    local gitstring="$c${b##refs/heads/}${f:+$z$f}$r$p";
    if [ $pcmode = yes ]; then
        if [ "${__git_printf_supports_v-}" != yes ]; then
            gitstring=$(printf -- "$printf_format" "$gitstring");
        else
            printf -v gitstring -- "$printf_format" "$gitstring";
        fi;
        PS1="$ps1pc_start$gitstring$ps1pc_end";
    else
        printf -- "$printf_format" "$gitstring";
    fi
}
__git_ps1_colorize_gitstring () 
{ 
    if [[ -n ${ZSH_VERSION-} ]]; then
        local c_red='%F{red}';
        local c_green='%F{green}';
        local c_lblue='%F{blue}';
        local c_clear='%f';
    else
        local c_red='\[\e[31m\]';
        local c_green='\[\e[32m\]';
        local c_lblue='\[\e[1;34m\]';
        local c_clear='\[\e[0m\]';
    fi;
    local bad_color=$c_red;
    local ok_color=$c_green;
    local flags_color="$c_lblue";
    local branch_color="";
    if [ $detached = no ]; then
        branch_color="$ok_color";
    else
        branch_color="$bad_color";
    fi;
    c="$branch_color$c";
    z="$c_clear$z";
    if [ "$w" = "*" ]; then
        w="$bad_color$w";
    fi;
    if [ -n "$i" ]; then
        i="$ok_color$i";
    fi;
    if [ -n "$s" ]; then
        s="$flags_color$s";
    fi;
    if [ -n "$u" ]; then
        u="$bad_color$u";
    fi;
    r="$c_clear$r"
}
__git_ps1_show_upstream () 
{ 
    local key value;
    local svn_remote svn_url_pattern count n;
    local upstream=git legacy="" verbose="" name="";
    svn_remote=();
    local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')";
    while read -r key value; do
        case "$key" in 
            bash.showupstream)
                GIT_PS1_SHOWUPSTREAM="$value";
                if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
                    p="";
                    return;
                fi
            ;;
            svn-remote.*.url)
                svn_remote[$((${#svn_remote[@]} + 1))]="$value";
                svn_url_pattern="$svn_url_pattern\\|$value";
                upstream=svn+git
            ;;
        esac;
    done <<< "$output";
    for option in ${GIT_PS1_SHOWUPSTREAM};
    do
        case "$option" in 
            git | svn)
                upstream="$option"
            ;;
            verbose)
                verbose=1
            ;;
            legacy)
                legacy=1
            ;;
            name)
                name=1
            ;;
        esac;
    done;
    case "$upstream" in 
        git)
            upstream="@{upstream}"
        ;;
        svn*)
            local -a svn_upstream;
            svn_upstream=($(git log --first-parent -1 					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null));
            if [[ 0 -ne ${#svn_upstream[@]} ]]; then
                svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]};
                svn_upstream=${svn_upstream%@*};
                local n_stop="${#svn_remote[@]}";
                for ((n=1; n <= n_stop; n++))
                do
                    svn_upstream=${svn_upstream#${svn_remote[$n]}};
                done;
                if [[ -z "$svn_upstream" ]]; then
                    upstream=${GIT_SVN_ID:-git-svn};
                else
                    upstream=${svn_upstream#/};
                fi;
            else
                if [[ "svn+git" = "$upstream" ]]; then
                    upstream="@{upstream}";
                fi;
            fi
        ;;
    esac;
    if [[ -z "$legacy" ]]; then
        count="$(git rev-list --count --left-right 				"$upstream"...HEAD 2>/dev/null)";
    else
        local commits;
        if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; then
            local commit behind=0 ahead=0;
            for commit in $commits;
            do
                case "$commit" in 
                    "<"*)
                        ((behind++))
                    ;;
                    *)
                        ((ahead++))
                    ;;
                esac;
            done;
            count="$behind	$ahead";
        else
            count="";
        fi;
    fi;
    if [[ -z "$verbose" ]]; then
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p="="
            ;;
            "0	"*)
                p=">"
            ;;
            *"	0")
                p="<"
            ;;
            *)
                p="<>"
            ;;
        esac;
    else
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p=" u="
            ;;
            "0	"*)
                p=" u+${count#0	}"
            ;;
            *"	0")
                p=" u-${count%	0}"
            ;;
            *)
                p=" u+${count#*	}-${count%	*}"
            ;;
        esac;
        if [[ -n "$count" && -n "$name" ]]; then
            p="$p $(git rev-parse --abbrev-ref "$upstream" 2>/dev/null)";
        fi;
    fi
}
__grub_dir () 
{ 
    local i c=1 boot_dir;
    for ((c=1; c <= ${#COMP_WORDS[@]}; c++ ))
    do
        i="${COMP_WORDS[c]}";
        case "$i" in 
            --boot-directory)
                c=$((++c));
                i="${COMP_WORDS[c]}";
                boot_dir="${i##*=}";
                break
            ;;
        esac;
    done;
    boot_dir=${boot_dir-/boot};
    echo "${boot_dir%/}/grub"
}
__grub_get_last_option () 
{ 
    local i;
    for ((i=$COMP_CWORD-1; i > 0; i-- ))
    do
        if [[ "${COMP_WORDS[i]}" == -* ]]; then
            echo "${COMP_WORDS[i]}";
            break;
        fi;
    done
}
__grub_get_options_from_help () 
{ 
    local prog;
    if [ $# -ge 1 ]; then
        prog="$1";
    else
        prog="${COMP_WORDS[0]}";
    fi;
    local i IFS=" "'	''
';
    for i in $(LC_ALL=C $prog --help);
    do
        case $i in 
            --*)
                echo "${i%=*}"
            ;;
        esac;
    done
}
__grub_get_options_from_usage () 
{ 
    local prog;
    if [ $# -ge 1 ]; then
        prog="$1";
    else
        prog="${COMP_WORDS[0]}";
    fi;
    local i IFS=" "'	''
';
    for i in $(LC_ALL=C $prog --usage);
    do
        case $i in 
            \[--*\])
                i=${i#[};
                echo ${i%%?(=*)]}
            ;;
        esac;
    done
}
__grub_list_menuentries () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local config_file=$(__grub_dir)/grub.cfg;
    if [ -f "$config_file" ]; then
        local IFS='
';
        COMPREPLY=($(compgen             -W "$( awk -F "[\"']" '/menuentry/ { print $2 }' $config_file )"             -- "$cur" ));
    fi
}
__grub_list_modules () 
{ 
    local grub_dir=$(__grub_dir);
    local IFS='
';
    COMPREPLY=($( compgen -f -X '!*/*.mod' -- "${grub_dir}/$cur" | {
         while read -r tmp; do
             [ -n $tmp ] && {
                 tmp=${tmp##*/}
                 printf '%s\n' ${tmp%.mod}
             }
         done
         }
        ))
}
__grubcomp () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [ $# -gt 2 ]; then
        cur="$3";
    fi;
    case "$cur" in 
        --*=)
            COMPREPLY=()
        ;;
        *)
            local IFS=' ''	''
';
            COMPREPLY=($(compgen -P "${2-}" -W "${1-}" -S "${4-}" -- "$cur"))
        ;;
    esac
}
__loaded_modules () 
{ 
    while IFS='	' read idx name _; do
        printf "%s %s\n" "$idx" "$name";
    done < <(pactl list modules short 2> /dev/null)
}
__ltrim_colon_completions () 
{ 
    if [[ "$1" == *:* && "$COMP_WORDBREAKS" == *:* ]]; then
        local colon_word=${1%"${1##*:}"};
        local i=${#COMPREPLY[*]};
        while [[ $((--i)) -ge 0 ]]; do
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
        done;
    fi
}
__parse_options () 
{ 
    local option option2 i IFS=' 	
,/|';
    option=;
    for i in $1;
    do
        case $i in 
            ---*)
                break
            ;;
            --?*)
                option=$i;
                break
            ;;
            -?*)
                [[ -n $option ]] || option=$i
            ;;
            *)
                break
            ;;
        esac;
    done;
    [[ -n $option ]] || return 0;
    IFS=' 	
';
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        printf '%s\n' "${option2/=*/=}";
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
    fi;
    option=${option%%[<{().[]*};
    printf '%s\n' "${option/=*/=}"
}
__ports () 
{ 
    pactl list cards 2> /dev/null | awk -e '/^\tPorts:/ {
            flag=1; next
         }

         /^\t[A-Za-z]/ {
             flag=0
         }

         flag {
             if (/^\t\t[A-Za-z]/)
                 ports = ports substr($0, 3, index($0, ":")-3) " "
         }

         END {
             print ports
         }'
}
__profiles () 
{ 
    pactl list cards 2> /dev/null | awk -e '/^\tProfiles:/ {
            flag=1; next
        }

        /^\t[A-Za-z]/ {
            flag=0
        }

        flag {
            if (/^\t\t[A-Za-z]/)
                profiles = profiles substr($0, 3, index($0, ": ")-3) " "
        }

        END {
            print profiles
        }'
}
__reassemble_comp_words_by_ref () 
{ 
    local exclude i j line ref;
    if [[ -n $1 ]]; then
        exclude="${1//[^$COMP_WORDBREAKS]}";
    fi;
    eval $3=$COMP_CWORD;
    if [[ -n $exclude ]]; then
        line=$COMP_LINE;
        for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && ${COMP_WORDS[$i]} == +([$exclude]) ]]; do
                [[ $line != [' 	']* ]] && (( j >= 2 )) && ((j--));
                ref="$2[$j]";
                eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
                [[ $i == $COMP_CWORD ]] && eval $3=$j;
                line=${line#*"${COMP_WORDS[$i]}"};
                [[ $line == [' 	']* ]] && ((j++));
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
            line=${line#*"${COMP_WORDS[i]}"};
            [[ $i == $COMP_CWORD ]] && eval $3=$j;
        done;
        [[ $i == $COMP_CWORD ]] && eval $3=$j;
    else
        eval $2=\( \"\${COMP_WORDS[@]}\" \);
    fi
}
__resample_methods () 
{ 
    while read name; do
        printf "%s\n" "$name";
    done < <(pulseaudio --dump-resample-methods 2> /dev/null)
}
__sink_inputs () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list sink-inputs short 2> /dev/null)
}
__sinks () 
{ 
    while IFS='	' read _ name _ _ _; do
        printf "%s\n" "$name";
    done < <(pactl list sinks short 2> /dev/null)
}
__sinks_idx () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list sinks short 2> /dev/null)
}
__source_outputs () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list source-outputs short 2> /dev/null)
}
__sources () 
{ 
    while IFS='	' read _ name _ _ _; do
        printf "%s\n" "$name";
    done < <(pactl list sources short 2> /dev/null)
}
_allowed_groups () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -g -- "$1" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -Gn 2>/dev/null || groups 2>/dev/null )" -- "$1" ));
    fi
}
_allowed_users () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -u -- "${1:-$cur}" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -un 2>/dev/null || whoami 2>/dev/null )" -- "${1:-$cur}" ));
    fi
}
_apport-bug () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help --save -v --version --tag -w --window';
    case "$prev" in 
        ubuntu-bug | apport-bug)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions="--tag";
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-cli () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help -f --file-bug -u --update-bug -s --symptom \
                 -c --crash-file --save -v --version --tag -w --window';
    case "$prev" in 
        apport-cli)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        -f | --file-bug)
            param="-P --pid -p --package -s --symptom";
            COMPREPLY=($( compgen -W "$param $(_apport_symptoms)" -- $cur))
        ;;
        -s | --symptom)
            COMPREPLY=($( compgen -W "$(_apport_symptoms)" -- $cur))
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -c | --crash-file)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions='--tag';
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--symptom.* || "${COMP_WORDS[*]}" =~ .*\ -s\ .* ]]; then
                dashoptions="-s --symptom $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--update.* || "${COMP_WORDS[*]}" =~ .*\ -u\ .* ]]; then
                dashoptions="-u --update $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--file-bug.* || "${COMP_WORDS[*]}" =~ .*\ -f\ .* ]]; then
                dashoptions="-f --file-bug $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--crash-file.* || "${COMP_WORDS[*]}" =~ .*\ -c\ .* ]]; then
                dashoptions="-c --crash-file $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-collect () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-collect)
            COMPREPLY=($( compgen -W "-p --package --tag" -- $cur))
        ;;
        -p | --package)
            COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ))
        ;;
        --tag)
            return 0
        ;;
        *)
            if [[ "${COMP_WORDS[*]}" =~ .*\ -p.* || "${COMP_WORDS[*]}" =~ .*--package.* ]]; then
                COMPREPLY=($( compgen -W "--tag" -- $cur));
            else
                COMPREPLY=($( compgen -W "-p --package --tag" -- $cur));
            fi
        ;;
    esac
}
_apport-unpack () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-unpack)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
    esac
}
_apport_parameterless () 
{ 
    local param;
    param="$dashoptions            $( apt-cache pkgnames $cur 2> /dev/null )            $( command ps axo pid | sed 1d )            $( _apport_symptoms )            $( compgen -G "${cur}*" )";
    COMPREPLY=($( compgen -W "$param" -- $cur))
}
_apport_symptoms () 
{ 
    local syms;
    if [ -r /usr/share/apport/symptoms ]; then
        for FILE in $(ls /usr/share/apport/symptoms);
        do
            if [[ ! "$FILE" =~ ^_.* && -n $(egrep "^def run\s*\(.*\):" /usr/share/apport/symptoms/$FILE) ]]; then
                syms="$syms ${FILE%.py}";
            fi;
        done;
    fi;
    echo $syms
}
_available_interfaces () 
{ 
    local cmd PATH=$PATH:/sbin;
    if [[ ${1:-} == -w ]]; then
        cmd="iwconfig";
    else
        if [[ ${1:-} == -a ]]; then
            cmd="{ ifconfig || ip link show up; }";
        else
            cmd="{ ifconfig -a || ip link show; }";
        fi;
    fi;
    COMPREPLY=($( eval $cmd 2>/dev/null | awk         '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur" ))
}
_axi_cache () 
{ 
    local cur prev cmd;
    COMPREPLY=();
    COMP_WORDBREAKS=${COMP_WORDBREAKS//:};
    type _get_comp_words_by_ref &> /dev/null && { 
        _get_comp_words_by_ref -n: cur prev
    } || { 
        cur=$(_get_cword ":");
        prev=${COMP_WORDS[$COMP_CWORD-1]}
    };
    cmd=${COMP_WORDS[1]};
    case "$prev" in 
        *axi-cache*)
            COMPREPLY=($(compgen -W "help more search show again showpkg showsrc depends rdepends policy madison" -- "$cur"));
            return 0
        ;;
        --sort)
            COMPREPLY=($(compgen -W "$(egrep ^[a-z] /var/lib/apt-xapian-index/values | awk -F"\t" '{print $1}')" -- "$cur"));
            return 0
        ;;
    esac;
    case "$cmd" in 
        search | again)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "--sort --tags" -- "$cur"));
                return 0;
            fi
        ;;
        show | showpkg | showsrc | depends | rdepends | policy | madison)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "--last" -- "$cur"));
                return 0;
            fi
        ;;
        *)
            return 0
        ;;
    esac;
    if [ -n "$cur" ]; then
        COMPREPLY=($(compgen -W "$(${COMP_WORDS[@]} --tabcomplete=partial)" -- "$cur"));
    else
        COMPREPLY=($(compgen -W "$(${COMP_WORDS[@]} --tabcomplete=plain)" -- "$cur"));
    fi;
    return 0
}
_cd () 
{ 
    local cur prev words cword;
    _init_completion || return;
    local IFS='
' i j k;
    compopt -o filenames;
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d;
        return 0;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $( compgen -d $i/$cur );
        do
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j+="/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]};
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return 0
}
_cd_devices () 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}" ))
}
_cmake () 
{ 
    local cur prev words cword split=false;
    _init_completion -n := || return;
    local prefix=;
    if [[ $cur == -D* ]]; then
        prev=-D;
        prefix=-D;
        cur="${cur#-D}";
    else
        if [[ $cur == -U* ]]; then
            prev=-U;
            prefix=-U;
            cur="${cur#-U}";
        fi;
    fi;
    case "$prev" in 
        -D)
            if [[ $cur == *=* ]]; then
                local var type value;
                var="${cur%%[:=]*}";
                value="${cur#*=}";
                if [[ $cur == CMAKE_BUILD_TYPE* ]]; then
                    COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                        MinSizeRel' -- "$value" ));
                    return;
                fi;
                if [[ $cur == *:* ]]; then
                    type="${cur#*:}";
                    type="${type%%=*}";
                else
                    type=$( cmake -LA -N 2>/dev/null | grep "$var:"                         2>/dev/null );
                    type="${type#*:}";
                    type="${type%%=*}";
                fi;
                case "$type" in 
                    FILEPATH)
                        cur="$value";
                        _filedir;
                        return
                    ;;
                    PATH)
                        cur="$value";
                        _filedir -d;
                        return
                    ;;
                    BOOL)
                        COMPREPLY=($( compgen -W 'ON OFF TRUE FALSE' --                             "$value" ));
                        return
                    ;;
                    STRING | INTERNAL)
                        return
                    ;;
                esac;
            else
                if [[ $cur == *:* ]]; then
                    local type="${cur#*:}";
                    COMPREPLY=($( compgen -W 'FILEPATH PATH STRING BOOL INTERNAL'                    -S = -- "$type" ));
                    compopt -o nospace;
                else
                    COMPREPLY=($( compgen -W '$( cmake -LA -N | tail -n +2 |
                    cut -f1 -d: )' -P "$prefix" -- "$cur" ));
                    compopt -o nospace;
                fi;
            fi;
            return
        ;;
        -U)
            COMPREPLY=($( compgen -W '$( cmake -LA -N | tail -n +2 |
                cut -f1 -d: )' -P "$prefix" -- "$cur" ));
            return
        ;;
    esac;
    _split_longopt && split=true;
    case "$prev" in 
        -C | -P | --graphviz | --system-information)
            _filedir;
            return
        ;;
        --build)
            _filedir -d;
            return
        ;;
        -E)
            COMPREPLY=($( compgen -W "$( cmake -E help |& sed -n                 '/^  /{s|^  \([^ ]\{1,\}\) .*$|\1|;p}' 2>/dev/null )"                 -- "$cur" ));
            return
        ;;
        -G)
            local IFS='
';
            local quoted;
            printf -v quoted %q "$cur";
            COMPREPLY=($( compgen -W '$( cmake --help 2>/dev/null | sed -n \
                -e "1,/^Generators/d" \
                -e "/^  *[^ =]/{s|^ *\([^=]*[^ =]\).*$|\1|;s| |\\\\ |g;p}" \
                2>/dev/null )' -- "$quoted" ));
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( cmake --help-command-list 2>/dev/null|
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-module)
            COMPREPLY=($( compgen -W '$( cmake --help-module-list 2>/dev/null|
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-policy)
            COMPREPLY=($( compgen -W '$( cmake --help-policies 2>/dev/null |
                grep "^  CMP" 2>/dev/null )' -- "$cur" ));
            return
        ;;
        --help-property)
            COMPREPLY=($( compgen -W '$( cmake --help-property-list \
                2>/dev/null | grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( cmake --help-variable-list \
                2>/dev/null | grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
    esac;
    $split && return;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_command () 
{ 
    local offset i;
    offset=1;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset () 
{ 
    local word_offset=$1 i j;
    for ((i=0; i < $word_offset; i++ ))
    do
        for ((j=0; j <= ${#COMP_LINE}; j++ ))
        do
            [[ "$COMP_LINE" == "${COMP_WORDS[i]}"* ]] && break;
            COMP_LINE=${COMP_LINE:1};
            ((COMP_POINT--));
        done;
        COMP_LINE=${COMP_LINE#"${COMP_WORDS[i]}"};
        ((COMP_POINT-=${#COMP_WORDS[i]}));
    done;
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++ ))
    do
        unset COMP_WORDS[i];
    done;
    ((COMP_CWORD -= $word_offset));
    COMPREPLY=();
    local cur;
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 0 ]]; then
        local IFS='
';
        compopt -o filenames;
        COMPREPLY=($( compgen -d -c -- "$cur" ));
    else
        local cmd=${COMP_WORDS[0]} compcmd=${COMP_WORDS[0]};
        local cspec=$( complete -p $cmd 2>/dev/null );
        if [[ ! -n $cspec && $cmd == */* ]]; then
            cspec=$( complete -p ${cmd##*/} 2>/dev/null );
            [[ -n $cspec ]] && compcmd=${cmd##*/};
        fi;
        if [[ ! -n $cspec ]]; then
            compcmd=${cmd##*/};
            _completion_loader $compcmd;
            cspec=$( complete -p $compcmd 2>/dev/null );
        fi;
        if [[ -n $cspec ]]; then
            if [[ ${cspec#* -F } != $cspec ]]; then
                local func=${cspec#*-F };
                func=${func%% *};
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                fi;
                local opt;
                while [[ $cspec == *" -o "* ]]; do
                    cspec=${cspec#*-o };
                    opt=${cspec%% *};
                    compopt -o $opt;
                    cspec=${cspec#$opt};
                done;
            else
                cspec=${cspec#complete};
                cspec=${cspec%%$compcmd};
                COMPREPLY=($( eval compgen "$cspec" -- '$cur' ));
            fi;
        else
            if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
                _minimal;
            fi;
        fi;
    fi
}
_complete_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
_completion_loader () 
{ 
    local compfile=./completions;
    [[ $BASH_SOURCE == */* ]] && compfile="${BASH_SOURCE%/*}/completions";
    compfile+="/${1##*/}";
    [[ -f "$compfile" ]] && . "$compfile" &> /dev/null && return 124;
    complete -F _minimal "$1" && return 124
}
_configured_interfaces () 
{ 
    if [[ -f /etc/debian_version ]]; then
        COMPREPLY=($( compgen -W "$( sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'            /etc/network/interfaces )" -- "$cur" ));
    else
        if [[ -f /etc/SuSE-release ]]; then
            COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
        else
            if [[ -f /etc/pld-release ]]; then
                COMPREPLY=($( compgen -W "$( command ls -B             /etc/sysconfig/interfaces |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            else
                COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            fi;
        fi;
    fi
}
_count_args () 
{ 
    local i cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    args=1;
    for i in "${words[@]:1:cword-1}";
    do
        [[ "$i" != -* ]] && args=$(($args+1));
    done
}
_cpack () 
{ 
    local cur prev words cword;
    _init_completion -n = || return;
    case "$prev" in 
        -G)
            COMPREPLY=($( compgen -W '$( cpack --help 2>/dev/null |
                sed -e "1,/^Generators/d" -e "s|^ *\([^ ]*\) .*$|\1|" \
                2>/dev/null )' -- "$cur" ));
            return
        ;;
        -C)
            COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                MinSizeRel' -- "$cur" ));
            return
        ;;
        -D)
            [[ $cur == *=* ]] && return;
            COMPREPLY=($( compgen -W '$( cpack --help-variable-list \
                2>/dev/null | grep -v "^cpack version " )' -S = -- "$cur" ));
            compopt -o nospace;
            return
        ;;
        -P | -R | --vendor)
            return
        ;;
        -B)
            _filedir -d;
            return
        ;;
        --config)
            _filedir;
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( cpack --help-command-list 2>/dev/null|
                grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( cpack --help-variable-list \
                2>/dev/null | grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_ctest () 
{ 
    local cur prev words cword;
    _init_completion -n = || return;
    case "$prev" in 
        -C | --build-config)
            COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                MinSizeRel' -- "$cur" ));
            return
        ;;
        -j | --parallel)
            COMPREPLY=($( compgen -W "{1..$(( $(_ncpus)*2 ))}" -- "$cur" ));
            return
        ;;
        -O | --output-log | -A | --add-notes | --extra-submit)
            _filedir;
            return
        ;;
        -L | --label-regex | -LE | --label-exclude | --track | -I | --tests-information | --max-width | --timeout | --stop-time)
            return
        ;;
        -R | --tests-regex | -E | --exclude-regex)
            COMPREPLY=($( compgen -W '$( ctest -N 2>/dev/null |
                grep "^  Test" 2>/dev/null | cut -d: -f 2 )' -- "$cur" ));
            return
        ;;
        -D | --dashboard)
            if [[ $cur == @(Experimental|Nightly|Continuous)* ]]; then
                local model action;
                action=${cur#@(Experimental|Nightly|Continuous)};
                model=${cur%"$action"};
                COMPREPLY=($( compgen -W 'Start Update Configure Build Test
                    Coverage Submit MemCheck' -P "$model" -- "$action" ));
            else
                COMPREPLY=($( compgen -W 'Experimental Nightly Continuous'                 -- "$cur" ));
                compopt -o nospace;
            fi;
            return
        ;;
        -M | --test-model)
            COMPREPLY=($( compgen -W 'Experimental Nightly Continuous' --                 "$cur" ));
            return
        ;;
        -T | --test-action)
            COMPREPLY=($( compgen -W 'Start Update Configure Build Test
                Coverage Submit MemCheck' -- "$cur" ));
            return
        ;;
        -S | --script | -SP | --script-new-process)
            _filedir '@(cmake|ctest)';
            return
        ;;
        --interactive-debug-mode)
            COMPREPLY=($( compgen -W '0 1' -- "$cur" ));
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( ctest --help-command-list 2>/dev/null|
                grep -v "^ctest version " )' -- "$cur" ));
            return
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_debconf_show () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=($( compgen -W '--listowners --listdbs --db=' -- $cur ) $( apt-cache pkgnames -- $cur ))
}
_desktop_file_validate () 
{ 
    COMPRELY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _filedir '@(desktop)'
}
_docker () 
{ 
    local previous_extglob_setting=$(shopt -p extglob);
    shopt -s extglob;
    local commands=(attach build commit container cp create diff events exec export history image images import info inspect kill load login logout logs network node pause plugin port ps pull push rename restart rm rmi run save search secret service stack start stats stop swarm system tag top unpause update version volume wait);
    local experimental_commands=(deploy);
    local global_boolean_options="
		--debug -D
		--tls
		--tlsverify
	";
    local global_options_with_args="
		--config
		--host -H
		--log-level -l
		--tlscacert
		--tlscert
		--tlskey
	";
    local host config;
    COMPREPLY=();
    local cur prev words cword;
    _get_comp_words_by_ref -n : cur prev words cword;
    local command='docker' command_pos=0 subcommand_pos;
    local counter=1;
    while [ $counter -lt $cword ]; do
        case "${words[$counter]}" in 
            --host | -H)
                (( counter++ ));
                host="${words[$counter]}"
            ;;
            --config)
                (( counter++ ));
                config="${words[$counter]}"
            ;;
            $(__docker_to_extglob "$global_options_with_args"))
                (( counter++ ))
            ;;
            -*)

            ;;
            =)
                (( counter++ ))
            ;;
            *)
                command="${words[$counter]}";
                command_pos=$counter;
                break
            ;;
        esac;
        (( counter++ ));
    done;
    local binary="${words[0]}";
    if [[ $binary == ?(*/)dockerd ]]; then
        command=daemon;
        command_pos=0;
    fi;
    local completions_func=_docker_${command};
    declare -F $completions_func > /dev/null && $completions_func;
    eval "$previous_extglob_setting";
    return 0
}
_docker_attach () 
{ 
    _docker_container_attach
}
_docker_build () 
{ 
    _docker_image_build
}
_docker_commit () 
{ 
    _docker_container_commit
}
_docker_container () 
{ 
    local subcommands="
		attach
		commit
		cp
		create
		diff
		exec
		export
		inspect
		kill
		logs
		ls
		pause
		port
		prune
		rename
		restart
		rm
		run
		start
		stats
		stop
		top
		unpause
		update
		wait
	";
    local aliases="
		list
		ps
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_container_attach () 
{ 
    __docker_complete_detach-keys && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach-keys --help --no-stdin --sig-proxy=false" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--detach-keys');
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_container_commit () 
{ 
    case "$prev" in 
        --author | -a | --change | -c | --message | -m)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--author -a --change -c --help --message -m --pause=false -p=false" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--author|-a|--change|-c|--message|-m');
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
                return;
            fi;
            (( counter++ ));
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
                return;
            fi
        ;;
    esac
}
_docker_container_cp () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--follow-link -L --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                case "$cur" in 
                    *:)
                        return
                    ;;
                    *)
                        _filedir;
                        local files=(${COMPREPLY[@]});
                        __docker_complete_containers_all;
                        COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                        local containers=(${COMPREPLY[@]});
                        COMPREPLY=($( compgen -W "${files[*]} ${containers[*]}" -- "$cur" ));
                        if [[ "$COMPREPLY" == *: ]]; then
                            __docker_nospace;
                        fi;
                        return
                    ;;
                esac;
            fi;
            (( counter++ ));
            if [ $cword -eq $counter ]; then
                if [ -e "$prev" ]; then
                    __docker_complete_containers_all;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace;
                else
                    _filedir;
                fi;
                return;
            fi
        ;;
    esac
}
_docker_container_create () 
{ 
    _docker_container_run
}
_docker_container_diff () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_exec () 
{ 
    __docker_complete_detach-keys && return;
    case "$prev" in 
        --env | -e)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach -d --detach-keys --env -e --help --interactive -i --privileged -t --tty -u --user" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_export () 
{ 
    case "$prev" in 
        --output | -o)
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --output -o" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_inspect () 
{ 
    _docker_inspect --type container
}
_docker_container_kill () 
{ 
    case "$prev" in 
        --signal | -s)
            __docker_complete_signals;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --signal -s" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_list () 
{ 
    _docker_container_ls
}
_docker_container_logs () 
{ 
    case "$prev" in 
        --since | --tail)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--details --follow -f --help --since --tail --timestamps -t" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--since|--tail');
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        ancestor)
            cur="${cur##*=}";
            __docker_complete_images;
            return
        ;;
        before)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        id)
            __docker_complete_containers_all --cur "${cur##*=}" --id;
            return
        ;;
        health)
            COMPREPLY=($( compgen -W "healthy starting none unhealthy" -- "${cur##*=}" ));
            return
        ;;
        is-task)
            COMPREPLY=($( compgen -W "true false" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_containers_all --cur "${cur##*=}" --name;
            return
        ;;
        network)
            __docker_complete_networks --cur "${cur##*=}";
            return
        ;;
        since)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        status)
            COMPREPLY=($( compgen -W "created dead exited paused restarting running removing" -- "${cur##*=}" ));
            return
        ;;
        volume)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "ancestor before exited health id is-task label name network since status volume" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format | --last | -n)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --filter -f --format --help --last -n --latest -l --no-trunc --quiet -q --size -s" -- "$cur" ))
        ;;
    esac
}
_docker_container_pause () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_port () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_prune () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_container_ps () 
{ 
    _docker_container_ls
}
_docker_container_rename () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_restart () 
{ 
    case "$prev" in 
        --time | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --time -t" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_container_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --link -l --volumes -v" -- "$cur" ))
        ;;
        *)
            for arg in "${COMP_WORDS[@]}";
            do
                case "$arg" in 
                    --force | -f)
                        __docker_complete_containers_all;
                        return
                    ;;
                esac;
            done;
            __docker_complete_containers_stopped
        ;;
    esac
}
_docker_container_run () 
{ 
    local options_with_args="
		--add-host
		--attach -a
		--blkio-weight
		--blkio-weight-device
		--cap-add
		--cap-drop
		--cgroup-parent
		--cidfile
		--cpu-period
		--cpu-quota
		--cpu-rt-period
		--cpu-rt-runtime
		--cpuset-cpus
		--cpus
		--cpuset-mems
		--cpu-shares -c
		--device
		--device-read-bps
		--device-read-iops
		--device-write-bps
		--device-write-iops
		--dns
		--dns-option
		--dns-search
		--entrypoint
		--env -e
		--env-file
		--expose
		--group-add
		--hostname -h
		--ip
		--ip6
		--ipc
		--isolation
		--kernel-memory
		--label-file
		--label -l
		--link
		--link-local-ip
		--log-driver
		--log-opt
		--mac-address
		--memory -m
		--memory-swap
		--memory-swappiness
		--memory-reservation
		--name
		--network
		--network-alias
		--oom-score-adj
		--pid
		--pids-limit
		--publish -p
		--restart
		--runtime
		--security-opt
		--shm-size
		--stop-signal
		--stop-timeout
		--storage-opt
		--tmpfs
		--sysctl
		--ulimit
		--user -u
		--userns
		--uts
		--volume-driver
		--volumes-from
		--volume -v
		--workdir -w
	";
    local boolean_options="
		--disable-content-trust=false
		--help
		--interactive -i
		--oom-kill-disable
		--privileged
		--publish-all -P
		--read-only
		--tty -t
	";
    if [ "$command" = "run" -o "$subcommand" = "run" ]; then
        options_with_args="$options_with_args
			--detach-keys
			--health-cmd
			--health-interval
			--health-retries
			--health-timeout
		";
        boolean_options="$boolean_options
			--detach -d
			--no-healthcheck
			--rm
			--sig-proxy=false
		";
        __docker_complete_detach-keys && return;
    fi;
    local all_options="$options_with_args $boolean_options";
    __docker_complete_log_driver_options && return;
    __docker_complete_restart && return;
    local key=$(__docker_map_key_of_current_option '--security-opt');
    case "$key" in 
        label)
            [[ $cur == *: ]] && return;
            COMPREPLY=($( compgen -W "user: role: type: level: disable" -- "${cur##*=}"));
            if [ "${COMPREPLY[*]}" != "disable" ]; then
                __docker_nospace;
            fi;
            return
        ;;
        seccomp)
            local cur=${cur##*=};
            _filedir;
            COMPREPLY+=($( compgen -W "unconfined" -- "$cur" ));
            return
        ;;
    esac;
    case "$prev" in 
        --add-host)
            case "$cur" in 
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --attach | -a)
            COMPREPLY=($( compgen -W 'stdin stdout stderr' -- "$cur" ));
            return
        ;;
        --cap-add | --cap-drop)
            __docker_complete_capabilities;
            return
        ;;
        --cidfile | --env-file | --label-file)
            _filedir;
            return
        ;;
        --device | --tmpfs | --volume | -v)
            case "$cur" in 
                *:*)

                ;;
                '')
                    COMPREPLY=($( compgen -W '/' -- "$cur" ));
                    __docker_nospace
                ;;
                /*)
                    _filedir;
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --env | -e)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --ipc)
            case "$cur" in 
                *:*)
                    cur="${cur#*:}";
                    __docker_complete_containers_running
                ;;
                *)
                    COMPREPLY=($( compgen -W 'host container:' -- "$cur" ));
                    if [ "$COMPREPLY" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --isolation)
            __docker_complete_isolation;
            return
        ;;
        --link)
            case "$cur" in 
                *:*)

                ;;
                *)
                    __docker_complete_containers_running;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --network)
            case "$cur" in 
                container:*)
                    __docker_complete_containers_all --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W "$(__docker_plugins_bundled --type Network) $(__docker_networks) container:" -- "$cur"));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --pid)
            case "$cur" in 
                *:*)
                    __docker_complete_containers_running --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W 'host container:' -- "$cur" ));
                    if [ "$COMPREPLY" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --runtime)
            __docker_complete_runtimes;
            return
        ;;
        --security-opt)
            COMPREPLY=($( compgen -W "apparmor= label= no-new-privileges seccomp=" -- "$cur"));
            if [ "${COMPREPLY[*]}" != "no-new-privileges" ]; then
                __docker_nospace;
            fi;
            return
        ;;
        --storage-opt)
            COMPREPLY=($( compgen -W "size" -S = -- "$cur"));
            __docker_nospace;
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
        --userns)
            COMPREPLY=($( compgen -W "host" -- "$cur" ));
            return
        ;;
        --volume-driver)
            __docker_complete_plugins_bundled --type Volume;
            return
        ;;
        --volumes-from)
            __docker_complete_containers_all;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag $( __docker_to_alternatives "$options_with_args" ) );
            if [ $cword -eq $counter ]; then
                __docker_complete_images;
            fi
        ;;
    esac
}
_docker_container_start () 
{ 
    __docker_complete_detach-keys && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--attach -a --detach-keys --help --interactive -i" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_stopped
        ;;
    esac
}
_docker_container_stats () 
{ 
    case "$prev" in 
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --format --help --no-stream" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_stop () 
{ 
    case "$prev" in 
        --time | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --time -t" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_top () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_container_unpause () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_unpauseable;
            fi
        ;;
    esac
}
_docker_container_update () 
{ 
    local options_with_args="
		--blkio-weight
		--cpu-period
		--cpu-quota
		--cpu-rt-period
		--cpu-rt-runtime
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares -c
		--kernel-memory
		--memory -m
		--memory-reservation
		--memory-swap
		--restart
	";
    local boolean_options="
		--help
	";
    local all_options="$options_with_args $boolean_options";
    __docker_complete_restart && return;
    case "$prev" in 
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_container_wait () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_cp () 
{ 
    _docker_container_cp
}
_docker_create () 
{ 
    _docker_container_run
}
_docker_daemon () 
{ 
    local boolean_options="
		$global_boolean_options
		--disable-legacy-registry
		--experimental
		--help
		--icc=false
		--ip-forward=false
		--ip-masq=false
		--iptables=false
		--ipv6
		--live-restore
		--raw-logs
		--selinux-enabled
		--userland-proxy=false
	";
    local options_with_args="
		$global_options_with_args
		--add-runtime
		--api-cors-header
		--authorization-plugin
		--bip
		--bridge -b
		--cgroup-parent
		--cluster-advertise
		--cluster-store
		--cluster-store-opt
		--config-file
		--containerd
		--default-gateway
		--default-gateway-v6
		--default-ulimit
		--dns
		--dns-search
		--dns-opt
		--exec-opt
		--exec-root
		--fixed-cidr
		--fixed-cidr-v6
		--graph -g
		--group -G
		--init-path
		--insecure-registry
		--ip
		--label
		--log-driver
		--log-opt
		--max-concurrent-downloads
		--max-concurrent-uploads
		--mtu
		--oom-score-adjust
		--pidfile -p
		--registry-mirror
		--seccomp-profile
		--shutdown-timeout
		--storage-driver -s
		--storage-opt
		--userland-proxy-path
		--userns-remap
	";
    __docker_complete_log_driver_options && return;
    key=$(__docker_map_key_of_current_option '--cluster-store-opt');
    case "$key" in 
        kv.*file)
            cur=${cur##*=};
            _filedir;
            return
        ;;
    esac;
    local key=$(__docker_map_key_of_current_option '--storage-opt');
    case "$key" in 
        dm.blkdiscard | dm.override_udev_sync_check | dm.use_deferred_removal | dm.use_deferred_deletion)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        dm.fs)
            COMPREPLY=($( compgen -W "ext4 xfs" -- "${cur##*=}" ));
            return
        ;;
        dm.thinpooldev)
            cur=${cur##*=};
            _filedir;
            return
        ;;
    esac;
    case "$prev" in 
        --authorization-plugin)
            __docker_complete_plugins_bundled --type Authorization;
            return
        ;;
        --cluster-store)
            COMPREPLY=($( compgen -W "consul etcd zk" -S "://" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --cluster-store-opt)
            COMPREPLY=($( compgen -W "discovery.heartbeat discovery.ttl kv.cacertfile kv.certfile kv.keyfile kv.path" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --config-file | --containerd | --init-path | --pidfile | -p | --tlscacert | --tlscert | --tlskey | --userland-proxy-path)
            _filedir;
            return
        ;;
        --exec-root | --graph | -g)
            _filedir -d;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --storage-driver | -s)
            COMPREPLY=($( compgen -W "aufs btrfs devicemapper overlay  overlay2 vfs zfs" -- "$(echo $cur | tr '[:upper:]' '[:lower:]')" ));
            return
        ;;
        --storage-opt)
            local btrfs_options="btrfs.min_space";
            local devicemapper_options="
				dm.basesize
				dm.blkdiscard
				dm.blocksize
				dm.fs
				dm.loopdatasize
				dm.loopmetadatasize
				dm.min_free_space
				dm.mkfsarg
				dm.mountopt
				dm.override_udev_sync_check
				dm.thinpooldev
				dm.use_deferred_deletion
				dm.use_deferred_removal
			";
            local zfs_options="zfs.fsname";
            case $(__docker_value_of_option '--storage-driver|-s') in 
                '')
                    COMPREPLY=($( compgen -W "$btrfs_options $devicemapper_options $zfs_options" -S = -- "$cur" ))
                ;;
                btrfs)
                    COMPREPLY=($( compgen -W "$btrfs_options" -S = -- "$cur" ))
                ;;
                devicemapper)
                    COMPREPLY=($( compgen -W "$devicemapper_options" -S = -- "$cur" ))
                ;;
                zfs)
                    COMPREPLY=($( compgen -W "$zfs_options" -S = -- "$cur" ))
                ;;
                *)
                    return
                ;;
            esac;
            __docker_nospace;
            return
        ;;
        --log-level | -l)
            __docker_complete_log_levels;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --seccomp-profile)
            _filedir json;
            return
        ;;
        --userns-remap)
            __docker_complete_user_group;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
    esac
}
_docker_deploy () 
{ 
    __docker_is_experimental && _docker_stack_deploy
}
_docker_diff () 
{ 
    _docker_container_diff
}
_docker_docker () 
{ 
    local boolean_options="
		$global_boolean_options
		--help
		--version -v
	";
    case "$prev" in 
        --config)
            _filedir -d;
            return
        ;;
        --log-level | -l)
            __docker_complete_log_levels;
            return
        ;;
        $(__docker_to_extglob "$global_options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $global_options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$(__docker_to_extglob "$global_options_with_args")" );
            if [ $cword -eq $counter ]; then
                __docker_is_experimental && commands+=(${experimental_commands[*]});
                COMPREPLY=($( compgen -W "${commands[*]} help" -- "$cur" ));
            fi
        ;;
    esac
}
_docker_events () 
{ 
    _docker_system_events
}
_docker_exec () 
{ 
    _docker_container_exec
}
_docker_export () 
{ 
    _docker_container_export
}
_docker_help () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ $cword -eq $counter ]; then
        COMPREPLY=($( compgen -W "${commands[*]}" -- "$cur" ));
    fi
}
_docker_history () 
{ 
    _docker_image_history
}
_docker_image () 
{ 
    local subcommands="
		build
		history
		import
		inspect
		load
		ls
		prune
		pull
		push
		rm
		save
		tag
	";
    local aliases="
		images
		list
		remove
		rmi
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_image_build () 
{ 
    local options_with_args="
		--build-arg
		--cache-from
		--cgroup-parent
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares -c
		--cpu-period
		--cpu-quota
		--file -f
		--isolation
		--label
		--memory -m
		--memory-swap
		--network
		--shm-size
		--tag -t
		--ulimit
	";
    local boolean_options="
		--compress
		--disable-content-trust=false
		--force-rm
		--help
		--no-cache
		--pull
		--quiet -q
		--rm
	";
    local all_options="$options_with_args $boolean_options";
    case "$prev" in 
        --build-arg)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --cache-from)
            __docker_complete_image_repos_and_tags;
            return
        ;;
        --file | -f)
            _filedir;
            return
        ;;
        --isolation)
            __docker_complete_isolation;
            return
        ;;
        --network)
            case "$cur" in 
                container:*)
                    __docker_complete_containers_all --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W "$(__docker_plugins --type Network) $(__docker_networks) container:" -- "$cur"));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --tag | -t)
            __docker_complete_image_repos_and_tags;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag $( __docker_to_alternatives "$options_with_args" ) );
            if [ $cword -eq $counter ]; then
                _filedir -d;
            fi
        ;;
    esac
}
_docker_image_history () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --human=false -H=false --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_images;
            fi
        ;;
    esac
}
_docker_image_images () 
{ 
    _docker_image_ls
}
_docker_image_import () 
{ 
    case "$prev" in 
        --change | -c | --message | -m)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--change -c --help --message -m" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--change|-c|--message|-m');
            if [ $cword -eq $counter ]; then
                return;
            fi;
            (( counter++ ));
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
                return;
            fi
        ;;
    esac
}
_docker_image_inspect () 
{ 
    _docker_inspect --type image
}
_docker_image_list () 
{ 
    _docker_image_ls
}
_docker_image_load () 
{ 
    case "$prev" in 
        --input | -i)
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --input -i --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_image_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        before | since | reference)
            cur="${cur##*=}";
            __docker_complete_images;
            return
        ;;
        dangling)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        label)
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "before dangling label reference since" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --digests --filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
        =)
            return
        ;;
        *)
            __docker_complete_image_repos
        ;;
    esac
}
_docker_image_prune () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --force -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_image_pull () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all-tags -a --disable-content-trust=false --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                for arg in "${COMP_WORDS[@]}";
                do
                    case "$arg" in 
                        --all-tags | -a)
                            __docker_complete_image_repos;
                            return
                        ;;
                    esac;
                done;
                __docker_complete_image_repos_and_tags;
            fi
        ;;
    esac
}
_docker_image_push () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--disable-content-trust=false --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
            fi
        ;;
    esac
}
_docker_image_remove () 
{ 
    _docker_image_rm
}
_docker_image_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --no-prune" -- "$cur" ))
        ;;
        *)
            __docker_complete_images
        ;;
    esac
}
_docker_image_rmi () 
{ 
    _docker_image_rm
}
_docker_image_save () 
{ 
    case "$prev" in 
        --output | -o)
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --output -o" -- "$cur" ))
        ;;
        *)
            __docker_complete_images
        ;;
    esac
}
_docker_image_tag () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
                return;
            fi;
            (( counter++ ));
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
                return;
            fi
        ;;
    esac
}
_docker_images () 
{ 
    _docker_image_ls
}
_docker_import () 
{ 
    _docker_image_import
}
_docker_info () 
{ 
    _docker_system_info
}
_docker_inspect () 
{ 
    local preselected_type;
    local type;
    if [ "$1" = "--type" ]; then
        preselected_type=yes;
        type="$2";
    else
        type=$(__docker_value_of_option --type);
    fi;
    case "$prev" in 
        --format | -f)
            return
        ;;
        --type)
            if [ -z "$preselected_type" ]; then
                COMPREPLY=($( compgen -W "container image network node plugin service volume" -- "$cur" ));
                return;
            fi
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--format -f --help --size -s";
            if [ -z "$preselected_type" ]; then
                options+=" --type";
            fi;
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            case "$type" in 
                '')
                    COMPREPLY=($( compgen -W "
						$(__docker_containers --all)
						$(__docker_images)
						$(__docker_networks)
						$(__docker_nodes)
						$(__docker_plugins_installed)
						$(__docker_services)
						$(__docker_volumes)
					" -- "$cur" ))
                ;;
                container)
                    __docker_complete_containers_all
                ;;
                image)
                    __docker_complete_images
                ;;
                network)
                    __docker_complete_networks
                ;;
                node)
                    __docker_complete_nodes
                ;;
                plugin)
                    __docker_complete_plugins_installed
                ;;
                service)
                    __docker_complete_services
                ;;
                volume)
                    __docker_complete_volumes
                ;;
            esac
        ;;
    esac
}
_docker_kill () 
{ 
    _docker_container_kill
}
_docker_load () 
{ 
    _docker_image_load
}
_docker_login () 
{ 
    case "$prev" in 
        --password | -p | --username | -u)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --password -p --username -u" -- "$cur" ))
        ;;
    esac
}
_docker_logout () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_logs () 
{ 
    _docker_container_logs
}
_docker_network () 
{ 
    local subcommands="
		connect
		create
		disconnect
		inspect
		ls
		prune
		rm
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_network_connect () 
{ 
    local options_with_args="
		--alias
		--ip
		--ip6
		--link
		--link-local-ip
	";
    local boolean_options="
		--help
	";
    case "$prev" in 
        --link)
            case "$cur" in 
                *:*)

                ;;
                *)
                    __docker_complete_containers_running;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag $( __docker_to_alternatives "$options_with_args" ) );
            if [ $cword -eq $counter ]; then
                __docker_complete_networks;
            else
                if [ $cword -eq $(($counter + 1)) ]; then
                    __docker_complete_containers_all;
                fi;
            fi
        ;;
    esac
}
_docker_network_create () 
{ 
    case "$prev" in 
        --aux-address | --gateway | --internal | --ip-range | --ipam-opt | --ipv6 | --opt | -o | --subnet)
            return
        ;;
        --ipam-driver)
            COMPREPLY=($( compgen -W "default" -- "$cur" ));
            return
        ;;
        --driver | -d)
            __docker_complete_plugins_bundled --type Network --remove host --remove null --add macvlan;
            return
        ;;
        --label)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--attachable --aux-address --driver -d --gateway --help --internal --ip-range --ipam-driver --ipam-opt --ipv6 --label --opt -o --subnet" -- "$cur" ))
        ;;
    esac
}
_docker_network_disconnect () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_networks;
            else
                if [ $cword -eq $(($counter + 1)) ]; then
                    __docker_complete_containers_in_network "$prev";
                fi;
            fi
        ;;
    esac
}
_docker_network_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_networks
        ;;
    esac
}
_docker_network_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        driver)
            __docker_complete_plugins_bundled --cur "${cur##*=}" --type Network --add macvlan;
            return
        ;;
        id)
            __docker_complete_networks --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_networks --cur "${cur##*=}" --name;
            return
        ;;
        type)
            COMPREPLY=($( compgen -W "builtin custom" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "driver id label name type" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_network_prune () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_network_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_networks --filter type=custom
        ;;
    esac
}
_docker_node () 
{ 
    local subcommands="
		demote
		inspect
		ls list
		promote
		rm remove
		ps
		update
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_node_demote () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --filter role=manager
        ;;
    esac
}
_docker_node_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes_plus_self
        ;;
    esac
}
_docker_node_list () 
{ 
    _docker_node_ls
}
_docker_node_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_nodes --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_nodes --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "id label name" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_node_promote () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --filter role=worker
        ;;
    esac
}
_docker_node_ps () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        desired-state)
            COMPREPLY=($( compgen -W "accepted running" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "desired-state id label name" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --no-resolve --no-trunc" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes_plus_self
        ;;
    esac
}
_docker_node_remove () 
{ 
    _docker_node_rm
}
_docker_node_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes
        ;;
    esac
}
_docker_node_update () 
{ 
    case "$prev" in 
        --availability)
            COMPREPLY=($( compgen -W "active drain pause" -- "$cur" ));
            return
        ;;
        --role)
            COMPREPLY=($( compgen -W "manager worker" -- "$cur" ));
            return
        ;;
        --label-add | --label-rm)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--availability --help --label-add --label-rm --role" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes
        ;;
    esac
}
_docker_pause () 
{ 
    _docker_container_pause
}
_docker_plugin () 
{ 
    local subcommands="
		create
		disable
		enable
		inspect
		install
		ls
		push
		rm
		set
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_create () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--compress --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                return;
            else
                if [ $cword -eq $((counter + 1)) ]; then
                    _filedir -d;
                fi;
            fi
        ;;
    esac
}
_docker_plugin_disable () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_plugins_installed;
            fi
        ;;
    esac
}
_docker_plugin_enable () 
{ 
    case "$prev" in 
        --timeout)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --timeout" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--timeout');
            if [ $cword -eq $counter ]; then
                __docker_complete_plugins_installed;
            fi
        ;;
    esac
}
_docker_plugin_inspect () 
{ 
    case "$prev" in 
        --format | f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_plugins_installed
        ;;
    esac
}
_docker_plugin_install () 
{ 
    case "$prev" in 
        --alias)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--alias --disable --grant-all-permissions --help" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_list () 
{ 
    _docker_plugin_ls
}
_docker_plugin_ls () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --no-trunc" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_push () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_plugins_installed;
            fi
        ;;
    esac
}
_docker_plugin_remove () 
{ 
    _docker_plugin_rm
}
_docker_plugin_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_plugins_installed
        ;;
    esac
}
_docker_plugin_set () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_plugins_installed;
            fi
        ;;
    esac
}
_docker_port () 
{ 
    _docker_container_port
}
_docker_ps () 
{ 
    _docker_container_ls
}
_docker_pull () 
{ 
    _docker_image_pull
}
_docker_push () 
{ 
    _docker_image_push
}
_docker_rename () 
{ 
    _docker_container_rename
}
_docker_restart () 
{ 
    _docker_container_restart
}
_docker_rm () 
{ 
    _docker_container_rm
}
_docker_rmi () 
{ 
    _docker_image_rm
}
_docker_run () 
{ 
    _docker_container_run
}
_docker_save () 
{ 
    _docker_image_save
}
_docker_search () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        is-automated)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        is-official)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "is-automated is-official stars" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --limit)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter --help --limit --no-trunc" -- "$cur" ))
        ;;
    esac
}
_docker_secret () 
{ 
    local subcommands="
		create
		inspect
		ls
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_secret_create () 
{ 
    case "$prev" in 
        --label | -l)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --label -l" -- "$cur" ))
        ;;
    esac
}
_docker_secret_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_secrets
        ;;
    esac
}
_docker_secret_list () 
{ 
    _docker_secret_ls
}
_docker_secret_ls () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_secret_remove () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_secrets
        ;;
    esac
}
_docker_secret_rm () 
{ 
    _docker_secret_remove
}
_docker_service () 
{ 
    local subcommands="
		create
		inspect
		ls list
		rm remove
		scale
		ps
		update
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_service_create () 
{ 
    _docker_service_update
}
_docker_service_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_services
        ;;
    esac
}
_docker_service_list () 
{ 
    _docker_service_ls
}
_docker_service_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_services --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "id label name" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_service_ps () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        desired-state)
            COMPREPLY=($( compgen -W "accepted running" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "desired-state id name" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --no-resolve --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--filter|-f');
            if [ $cword -eq $counter ]; then
                __docker_complete_services;
            fi
        ;;
    esac
}
_docker_service_remove () 
{ 
    _docker_service_rm
}
_docker_service_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_services
        ;;
    esac
}
_docker_service_scale () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_services;
            __docker_append_to_completions "=";
            __docker_nospace
        ;;
    esac
}
_docker_service_update () 
{ 
    local $subcommand="${words[$subcommand_pos]}";
    local options_with_args="
		--constraint
		--endpoint-mode
		--env -e
		--force
		--health-cmd
		--health-interval
		--health-retries
		--health-timeout
		--hostname
		--label -l
		--limit-cpu
		--limit-memory
		--log-driver
		--log-opt
		--mount
		--network
		--no-healthcheck
		--publish -p
		--replicas
		--reserve-cpu
		--reserve-memory
		--restart-condition
		--restart-delay
		--restart-max-attempts
		--restart-window
		--rollback
		--stop-grace-period
		--update-delay
		--update-failure-action
		--update-max-failure-ratio
		--update-monitor
		--update-parallelism
		--user -u
		--workdir -w
	";
    local boolean_options="
		--help
		--tty -t
		--with-registry-auth
	";
    __docker_complete_log_driver_options && return;
    if [ "$subcommand" = "create" ]; then
        options_with_args="$options_with_args
			--container-label
			--dns
			--dns-option
			--dns-search
			--env-file
			--group
			--host
			--mode
			--name
			--publish
			--secret
		";
        case "$prev" in 
            --env-file)
                _filedir;
                return
            ;;
            --host)
                case "$cur" in 
                    *:)
                        __docker_complete_resolved_hostname;
                        return
                    ;;
                esac
            ;;
            --mode)
                COMPREPLY=($( compgen -W "global replicated" -- "$cur" ));
                return
            ;;
            --secret)
                __docker_complete_secrets;
                return
            ;;
            --group)
                COMPREPLY=($(compgen -g -- "$cur"));
                return
            ;;
        esac;
    fi;
    if [ "$subcommand" = "update" ]; then
        options_with_args="$options_with_args
			--arg
			--container-label-add
			--container-label-rm
			--dns-add
			--dns-option-add
			--dns-option-rm
			--dns-rm
			--dns-search-add
			--dns-search-rm
			--group-add
			--group-rm
			--host-add
			--host-rm
			--image
			--publish-add
			--publish-rm
			--secret-add
			--secret-rm
		";
        case "$prev" in 
            --group-add)
                COMPREPLY=($(compgen -g -- "$cur"));
                return
            ;;
            --group-rm)
                COMPREPLY=($(compgen -g -- "$cur"));
                return
            ;;
            --host-add | --host-rm)
                case "$cur" in 
                    *:)
                        __docker_complete_resolved_hostname;
                        return
                    ;;
                esac
            ;;
            --image)
                __docker_complete_image_repos_and_tags;
                return
            ;;
            --secret-add | --secret-rm)
                __docker_complete_secrets;
                return
            ;;
        esac;
    fi;
    case "$prev" in 
        --endpoint-mode)
            COMPREPLY=($( compgen -W "dnsrr vip" -- "$cur" ));
            return
        ;;
        --env | -e)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --network)
            __docker_complete_networks;
            return
        ;;
        --restart-condition)
            COMPREPLY=($( compgen -W "any none on-failure" -- "$cur" ));
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag $( __docker_to_alternatives "$options_with_args" ) );
            if [ "$subcommand" = "update" ]; then
                if [ $cword -eq $counter ]; then
                    __docker_complete_services;
                fi;
            else
                if [ $cword -eq $counter ]; then
                    __docker_complete_images;
                fi;
            fi
        ;;
    esac
}
_docker_stack () 
{ 
    local subcommands="
		deploy
		ls
		ps
		rm
		services
	";
    local aliases="
		down
		list
		remove
		up
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_stack_deploy () 
{ 
    case "$prev" in 
        --bundle-file)
            if __docker_is_experimental; then
                _filedir dab;
                return;
            fi
        ;;
        --compose-file | -c)
            _filedir yml;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--compose-file -c --help --with-registry-auth";
            __docker_is_experimental && options+=" --bundle-file";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
    esac
}
_docker_stack_down () 
{ 
    _docker_stack_rm
}
_docker_stack_list () 
{ 
    _docker_stack_ls
}
_docker_stack_ls () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_stack_ps () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        desired-state)
            COMPREPLY=($( compgen -W "accepted running" -- "${cur##*=}" ));
            return
        ;;
        id)
            __docker_complete_stacks --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_stacks --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id name desired-state" -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --filter -f --help --no-resolve --no-trunc" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--filter|-f');
            if [ $cword -eq $counter ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_remove () 
{ 
    _docker_stack_rm
}
_docker_stack_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_services () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_services --cur "${cur##*=}" --id;
            return
        ;;
        label)
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --quiet -q" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--filter|-f');
            if [ $cword -eq $counter ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_up () 
{ 
    _docker_stack_deploy
}
_docker_start () 
{ 
    _docker_container_start
}
_docker_stats () 
{ 
    _docker_container_stats
}
_docker_stop () 
{ 
    _docker_container_stop
}
_docker_swarm () 
{ 
    local subcommands="
		init
		join
		join-token
		leave
		update
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_init () 
{ 
    case "$prev" in 
        --advertise-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces;
                __docker_nospace;
            fi;
            return
        ;;
        --listen-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces --add 0.0.0.0;
                __docker_nospace;
            fi;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--advertise-addr --force-new-cluster --help --listen-addr" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_join () 
{ 
    case "$prev" in 
        --advertise-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces;
                __docker_nospace;
            fi;
            return
        ;;
        --listen-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces --add 0.0.0.0;
                __docker_nospace;
            fi;
            return
        ;;
        --token)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--advertise-addr --help --listen-addr --token" -- "$cur" ))
        ;;
        *:)
            COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ))
        ;;
    esac
}
_docker_swarm_join-token () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --quiet -q --rotate" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag );
            if [ $cword -eq $counter ]; then
                COMPREPLY=($( compgen -W "manager worker" -- "$cur" ));
            fi
        ;;
    esac
}
_docker_swarm_leave () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_update () 
{ 
    case "$prev" in 
        --cert-expiry | --dispatcher-heartbeat | --max-snapshots | --snapshot-interval | --task-history-limit)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--cert-expiry --dispatcher-heartbeat --help --max-snapshots --snapshot-interval --task-history-limit" -- "$cur" ))
        ;;
    esac
}
_docker_system () 
{ 
    local subcommands="
		df
		events
		info
		prune
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_system_df () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --verbose -v" -- "$cur" ))
        ;;
    esac
}
_docker_system_events () 
{ 
    local key=$(__docker_map_key_of_current_option '-f|--filter');
    case "$key" in 
        container)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        daemon)
            local name=$(__docker_q info | sed -n 's/^\(ID\|Name\): //p');
            COMPREPLY=($( compgen -W "$name" -- "${cur##*=}" ));
            return
        ;;
        event)
            COMPREPLY=($( compgen -W "
				attach
				commit
				connect
				copy
				create
				delete
				destroy
				detach
				die
				disconnect
				exec_create
				exec_detach
				exec_start
				export
				health_status
				import
				kill
				load
				mount
				oom
				pause
				pull
				push
				reload
				rename
				resize
				restart
				save
				start
				stop
				tag
				top
				unmount
				unpause
				untag
				update
			" -- "${cur##*=}" ));
            return
        ;;
        image)
            cur="${cur##*=}";
            __docker_complete_images;
            return
        ;;
        network)
            __docker_complete_networks --cur "${cur##*=}";
            return
        ;;
        type)
            COMPREPLY=($( compgen -W "container daemon image network volume" -- "${cur##*=}" ));
            return
        ;;
        volume)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "container daemon event image label network type volume" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --since | --until)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --since --until --format" -- "$cur" ))
        ;;
    esac
}
_docker_system_info () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_system_prune () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --force -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_tag () 
{ 
    _docker_image_tag
}
_docker_top () 
{ 
    _docker_container_top
}
_docker_unpause () 
{ 
    _docker_container_unpause
}
_docker_update () 
{ 
    _docker_container_update
}
_docker_version () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_volume () 
{ 
    local subcommands="
		create
		inspect
		ls
		prune
		rm
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_volume_create () 
{ 
    case "$prev" in 
        --driver | -d)
            __docker_complete_plugins_bundled --type Volume;
            return
        ;;
        --label | --opt | -o)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--driver -d --help --label --opt -o" -- "$cur" ))
        ;;
    esac
}
_docker_volume_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_volumes
        ;;
    esac
}
_docker_volume_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        dangling)
            COMPREPLY=($( compgen -W "true false" -- "${cur##*=}" ));
            return
        ;;
        driver)
            __docker_complete_plugins_bundled --cur "${cur##*=}" --type Volume;
            return
        ;;
        name)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "dangling driver label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_volume_prune () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_volume_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_volumes
        ;;
    esac
}
_docker_wait () 
{ 
    _docker_container_wait
}
_dvd_devices () 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}" ))
}
_expand () 
{ 
    if [[ "$cur" == \~*/* ]]; then
        eval cur=$cur 2> /dev/null;
    else
        if [[ "$cur" == \~* ]]; then
            cur=${cur#\~};
            COMPREPLY=($( compgen -P '~' -u "$cur" ));
            [[ ${#COMPREPLY[@]} -eq 1 ]] && eval COMPREPLY[0]=${COMPREPLY[0]};
            return ${#COMPREPLY[@]};
        fi;
    fi
}
_export () 
{ 
    local cur prev words cword;
    _init_completion -n = || return;
    local i action=variable remove=false;
    for ((i=1; i < cword; i++ ))
    do
        case ${words[i]} in 
            -p)
                return
            ;;
            -*f*)
                action=function
            ;;&
            -*n*)
                remove=true
            ;;
            -*)
                continue
            ;;
        esac;
        break;
    done;
    [[ $cur == *=\$* ]] && { 
        cur=${cur#*=};
        _variables
    } && return;
    case $cur in 
        *=)
            local pval=$( quote "$( eval printf %s \"\$${cur%=}\" )" );
            if [[ $pval != \'\' ]]; then
                COMPREPLY=("$pval");
            else
                cur=${cur#*=};
                _filedir;
            fi
        ;;
        *=*)
            cur=${cur#*=};
            _filedir
        ;;
        *)
            if [[ $cword -eq 1 && $cur == -* ]]; then
                COMPREPLY=($( compgen -W                     '-p $( _parse_usage "$1" )' -- "$cur" ));
                return;
            fi;
            local suffix;
            if ! $remove; then
                suffix+==;
                compopt -o nospace;
            fi;
            COMPREPLY=($( compgen -A $action -S "$suffix" -- "$cur" ))
        ;;
    esac
}
_filedir () 
{ 
    local i IFS='
' xspec;
    _tilde "$cur" || return 0;
    local -a toks;
    local quoted x tmp;
    _quote_readline_by_ref "$cur" quoted;
    x=$( compgen -d -- "$quoted" ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ "$1" != -d ]]; then
        xspec=${1:+"!*.@($1|${1^^})"};
        x=$( compgen -f -X "$xspec" -- $quoted ) && while read -r tmp; do
            toks+=("$tmp");
        done <<< "$x";
    fi;
    [[ -n ${COMP_FILEDIR_FALLBACK:-} && -n "$1" && "$1" != -d && ${#toks[@]} -lt 1 ]] && x=$( compgen -f -- $quoted ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames 2> /dev/null;
        COMPREPLY+=("${toks[@]}");
    fi
}
_filedir_xspec () 
{ 
    local cur prev words cword;
    _init_completion || return;
    _tilde "$cur" || return 0;
    local IFS='
' xspec=${_xspecs[${1##*/}]} tmp;
    local -a toks;
    toks=($(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            printf '%s\n' $tmp
        done
        }
        ));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    xspec="$matchop($xspec|${xspec^^})";
    toks+=($(
        eval compgen -f -X "!$xspec" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [[ -n $tmp ]] && printf '%s\n' $tmp
        done
        }
        ));
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames;
        COMPREPLY=("${toks[@]}");
    fi
}
_fstypes () 
{ 
    local fss;
    if [[ -e /proc/filesystems ]]; then
        fss="$( cut -d'	' -f2 /proc/filesystems )
             $( awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null )";
    else
        fss="$( awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null )
             $( awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null )
             $( [[ -d /etc/fs ]] && command ls /etc/fs )";
    fi;
    [[ -n $fss ]] && COMPREPLY+=($( compgen -W "$fss" -- "$cur" ))
}
_get_comp_words_by_ref () 
{ 
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash: $FUNCNAME(): \`${!OPTIND}': unknown argument" 1>&2;
                return 1
            ;;
        esac;
        let "OPTIND += 1";
    done;
    __get_cword_at_cursor_by_ref "$exclude" words cword cur;
    [[ -n $vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -n $vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -n $vprev && $cword -ge 1 ]] && { 
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -n $vwords ]] && { 
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords "${words[@]}")
    };
    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    if [[ -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword-$2]}";
    else
        if [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
            printf "%s" "${words[cword]}";
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i ))
            do
                while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    ((index--));
                done;
                if [[ "$i" -lt "$cword" ]]; then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    index=$(( index - old_size + new_size ));
                fi;
            done;
            if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:$index}";
            fi;
        fi;
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword () 
{ 
    if [[ $COMP_CWORD -ge 1 ]]; then
        _get_cword "${@:-}" 1;
    fi
}
_gids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent group | cut -d: -f3 )'             -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/group )' -- "$cur" ));
        fi;
    fi
}
_grub_editenv () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        create | list | set | unset)
            COMPREPLY=("");
            return
        ;;
    esac;
    __grubcomp "$(__grub_get_options_from_help)
                create list set unset"
}
_grub_install () 
{ 
    local cur prev last split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    last=$(__grub_get_last_option);
    _split_longopt && split=true;
    case "$prev" in 
        --boot-directory)
            _filedir -d;
            return
        ;;
        --disk-module)
            __grubcomp "biosdisk ata";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        case "$last" in 
            --modules)
                __grub_list_modules;
                return
            ;;
        esac;
        _filedir;
    fi
}
_grub_mkconfig () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkfont () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkimage () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --directory | -p | --prefix)
            _filedir -d;
            return
        ;;
        -O | --format)
            local prog=${COMP_WORDS[0]};
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F ":" '/available formats/ { print $2 }' |                         sed 's/, / /g')";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkpasswd_pbkdf2 () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkrescue () 
{ 
    local cur prev last;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    last=$(__grub_get_last_option);
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        case "$last" in 
            --modules)
                __grub_list_modules;
                return
            ;;
        esac;
        _filedir;
    fi
}
_grub_probe () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -t | --target)
            local prog=${COMP_WORDS[0]};
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F "[()]" '/--target=/ { print $2 }' |                         sed 's/|/ /g')";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_script_check () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_set_entry () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        --boot-directory)
            _filedir -d;
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        __grub_list_menuentries;
    fi
}
_grub_setup () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --directory)
            _filedir -d;
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_have () 
{ 
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type $1 &> /dev/null
}
_init_completion () 
{ 
    local exclude= flag outx errx inx OPTIND=1;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            n)
                exclude+=$OPTARG
            ;;
            e)
                errx=$OPTARG
            ;;
            o)
                outx=$OPTARG
            ;;
            i)
                inx=$OPTARG
            ;;
            s)
                split=false;
                exclude+==
            ;;
        esac;
    done;
    COMPREPLY=();
    local redir="@(?([0-9])<|?([0-9&])>?(>)|>&)";
    _get_comp_words_by_ref -n "$exclude<>&" cur prev words cword;
    _variables && return 1;
    if [[ $cur == $redir* || $prev == $redir ]]; then
        local xspec;
        case $cur in 
            2'>'*)
                xspec=$errx
            ;;
            *'>'*)
                xspec=$outx
            ;;
            *'<'*)
                xspec=$inx
            ;;
            *)
                case $prev in 
                    2'>'*)
                        xspec=$errx
                    ;;
                    *'>'*)
                        xspec=$outx
                    ;;
                    *'<'*)
                        xspec=$inx
                    ;;
                esac
            ;;
        esac;
        cur="${cur##$redir}";
        _filedir $xspec;
        return 1;
    fi;
    local i skip;
    for ((i=1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]} == $redir* ]]; then
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            [[ $i -le $cword ]] && cword=$(( cword - skip ));
        else
            i=$(( ++i ));
        fi;
    done;
    [[ $cword -le 0 ]] && return 1;
    prev=${words[cword-1]};
    [[ -n ${split-} ]] && _split_longopt && split=true;
    return 0
}
_installed_modules () 
{ 
    COMPREPLY=($( compgen -W "$( PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}' )" -- "$1" ))
}
_ip_addresses () 
{ 
    local PATH=$PATH:/sbin;
    COMPREPLY+=($( compgen -W         "$( { LC_ALL=C ifconfig -a || ip addr show; } 2>/dev/null |
            sed -ne 's/.*addr:\([^[:space:]]*\).*/\1/p'                 -ne 's|.*inet[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p' )"         -- "$cur" ))
}
_kernel_versions () 
{ 
    COMPREPLY=($( compgen -W '$( command ls /lib/modules )' -- "$cur" ))
}
_known_hosts () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    local options;
    [[ "$1" == -a || "$2" == -a ]] && options=-a;
    [[ "$1" == -c || "$2" == -c ]] && options+=" -c";
    _known_hosts_real $options -- "$cur"
}
_known_hosts_real () 
{ 
    local configfile flag prefix;
    local cur curd awkcur user suffix aliases i host;
    local -a kh khd config;
    local OPTIND=1;
    while getopts "acF:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
        esac;
    done;
    [[ $# -lt $OPTIND ]] && echo "error: $FUNCNAME: missing mandatory argument CWORD";
    cur=${!OPTIND};
    let "OPTIND += 1";
    [[ $# -ge $OPTIND ]] && echo "error: $FUNCNAME("$@"): unprocessed arguments:" $(while [[ $# -ge $OPTIND ]]; do printf '%s\n' ${!OPTIND}; shift; done);
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [[ -n $configfile ]]; then
        [[ -r $configfile ]] && config+=("$configfile");
    else
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        do
            [[ -r $i ]] && config+=("$i");
        done;
    fi;
    if [[ ${#config[@]} -gt 0 ]]; then
        local OIFS=$IFS IFS='
' j;
        local -a tmpkh;
        tmpkh=($( awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u ));
        IFS=$OIFS;
        for i in "${tmpkh[@]}";
        do
            while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
                i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                j=${BASH_REMATCH[2]};
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
            for j in $i;
            do
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
        done;
    fi;
    if [[ -z $configfile ]]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [[ -r $i ]] && kh+=("$i");
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [[ -d $i ]] && khd+=("$i"/*pub);
        done;
    fi;
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
        awkcur=${cur//\//\\\/};
        awkcur=${awkcur//\./\\\.};
        curd=$awkcur;
        if [[ "$awkcur" == [0-9]*[.:]* ]]; then
            awkcur="^$awkcur[.:]*";
        else
            if [[ "$awkcur" == [0-9]* ]]; then
                awkcur="^$awkcur.*[.:]";
            else
                if [[ -z $awkcur ]]; then
                    awkcur="[a-z.:]";
                else
                    awkcur="^$awkcur";
                fi;
            fi;
        fi;
        if [[ ${#kh[@]} -gt 0 ]]; then
            COMPREPLY+=($( awk 'BEGIN {FS=","}
            /^\s*[^|\#]/ {
            sub("^@[^ ]+ +", ""); \
            sub(" .*$", ""); \
            for (i=1; i<=NF; ++i) { \
            sub("^\\[", "", $i); sub("\\](:[0-9]+)?$", "", $i); \
            if ($i !~ /[*?]/ && $i ~ /'"$awkcur"'/) {print $i} \
            }}' "${kh[@]}" 2>/dev/null ));
        fi;
        if [[ ${#khd[@]} -gt 0 ]]; then
            for i in "${khd[@]}";
            do
                if [[ "$i" == *key_22_$curd*.pub && -r "$i" ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY+=($host);
                fi;
            done;
        fi;
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
        local hosts=$( sed -ne 's/^[ \t]*[Hh][Oo][Ss][Tt]\([Nn][Aa][Mm][Ee]\)\{0,1\}['"$'\t '"']\{1,\}\([^#*?]*\)\(#.*\)\{0,1\}$/\2/p' "${config[@]}" );
        COMPREPLY+=($( compgen -P "$prefix$user"             -S "$suffix" -W "$hosts" -- "$cur" ));
    fi;
    COMPREPLY+=($( compgen -W         "$( ruptime 2>/dev/null | awk '!/^ruptime:/ { print $1 }' )"         -- "$cur" ));
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1} ]]; then
        COMPREPLY+=($( compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur" ));
    fi;
    __ltrim_colon_completions "$prefix$user$cur";
    return 0
}
_loexp_ () 
{ 
    local c=${COMP_WORDS[COMP_CWORD]};
    local a="${COMP_LINE}";
    local e s g=0 cd dc t="";
    local IFS;
    shopt -q extglob && g=1;
    test $g -eq 0 && shopt -s extglob;
    cd='*-?(c)d*';
    dc='*-d?(c)*';
    case "${1##*/}" in 
        lomath)
            e='!*.+(sxm|SXM|smf|SMF|mml|MML|odf|ODF)'
        ;;
        lofromtemplate)
            e='!*.+(stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX)'
        ;;
        loimpress)
            e='!*.+(sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX)'
        ;;
        loffice)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxm|SXM|smf|SMF|mml|MML|odf|ODF|sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX|odb|ODB|sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX|sxg|SXG|odm|ODM|sgl|SGL|stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX|htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        lobase)
            e='!*.+(odb|ODB)'
        ;;
        libreoffice)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxm|SXM|smf|SMF|mml|MML|odf|ODF|sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX|odb|ODB|sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX|sxg|SXG|odm|ODM|sgl|SGL|stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX|htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        lowriter)
            e='!*.+(doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxg|SXG|odm|ODM|sgl|SGL)'
        ;;
        loweb)
            e='!*.+(htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        unopkg)
            e='!*.+(oxt|OXT)'
        ;;
        localc)
            e='!*.+(sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX)'
        ;;
        lodraw)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG)'
        ;;
        *)
            e='!*'
        ;;
    esac;
    case "$(complete -p ${1##*/} 2> /dev/null)" in 
        *-d*)

        ;;
        *)
            s="-S/"
        ;;
    esac;
    IFS='
';
    case "$c" in 
        \$\(*\))
            eval COMPREPLY=\(${c}\)
        ;;
        \$\(*)
            COMPREPLY=($(compgen -c -P '$(' -S ')'  -- ${c#??}))
        ;;
        \`*\`)
            eval COMPREPLY=\(${c}\)
        ;;
        \`*)
            COMPREPLY=($(compgen -c -P '\`' -S '\`' -- ${c#?}))
        ;;
        \$\{*\})
            eval COMPREPLY=\(${c}\)
        ;;
        \$\{*)
            COMPREPLY=($(compgen -v -P '${' -S '}'  -- ${c#??}))
        ;;
        \$*)
            COMPREPLY=($(compgen -v -P '$'          -- ${c#?}))
        ;;
        \~*/*)
            COMPREPLY=($(compgen -f -X "$e"         -- ${c}))
        ;;
        \~*)
            COMPREPLY=($(compgen -u ${s}	 	-- ${c}))
        ;;
        *@*)
            COMPREPLY=($(compgen -A hostname -P '@' -S ':' -- ${c#*@}))
        ;;
        *[*?[]*)
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *[?*+\!@]\(*\)*)
            if test $g -eq 0; then
                COMPREPLY=($(compgen -f -X "$e" -- $c));
                test $g -eq 0 && shopt -u extglob;
                return;
            fi;
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *)
            if test "$c" = ".."; then
                COMPREPLY=($(compgen -d -X "$e" -S / ${_nosp} -- $c));
            else
                for s in $(compgen -f -X "$e" -- $c);
                do
                    if test -d $s; then
                        COMPREPLY=(${COMPREPLY[@]} $(compgen -f -X "$e" -S / -- $s));
                    else
                        if test -z "$t"; then
                            COMPREPLY=(${COMPREPLY[@]} $s);
                        else
                            case "$(file -b $s 2> /dev/null)" in 
                                $t)
                                    COMPREPLY=(${COMPREPLY[@]} $s)
                                ;;
                            esac;
                        fi;
                    fi;
                done;
            fi
        ;;
    esac;
    test $g -eq 0 && shopt -u extglob
}
_longopt () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case "${prev,,}" in 
        --help | --usage | --version)
            return 0
        ;;
        --*dir*)
            _filedir -d;
            return 0
        ;;
        --*file* | --*path*)
            _filedir;
            return 0
        ;;
        --+([-a-z0-9_]))
            local argtype=$( $1 --help 2>&1 | sed -ne                 "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p" );
            case ${argtype,,} in 
                *dir*)
                    _filedir -d;
                    return 0
                ;;
                *file* | *path*)
                    _filedir;
                    return 0
                ;;
            esac
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             sed -ne 's/.*\(--[-A-Za-z0-9]\{1,\}=\{0,1\}\).*/\1/p' | sort -u )"             -- "$cur" ));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
    else
        if [[ "$1" == @(mk|rm)dir ]]; then
            _filedir -d;
        else
            _filedir;
        fi;
    fi
}
_mac_addresses () 
{ 
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY+=($(         { LC_ALL=C ifconfig -a || ip link show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]].*|\2|p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]]*$|\2|p"
        ));
    COMPREPLY+=($( { arp -an || ip neigh show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY+=($( sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
    __ltrim_colon_completions "$cur"
}
_minimal () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    $split && return;
    _filedir
}
_modules () 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($( compgen -W "$( command ls -RL $modpath 2>/dev/null |         sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p' )" -- "$cur" ))
}
_ncpus () 
{ 
    local var=NPROCESSORS_ONLN;
    [[ $OSTYPE == *linux* ]] && var=_$var;
    local n=$( getconf $var 2>/dev/null );
    printf %s ${n:-1}
}
_pacat () 
{ 
    local cur prev comps;
    local flags='-h --help --version -r --record -p --playback -v --verbose -s
                --server= -d --device= -n --client-name= --stream-name= --volume=
                --rate= --format= --channels= --channel-map= --fix-format --fix-rate
                --fix-channels --no-remix --no-remap --latency= --process-time=
                --latency-msec= --process-time-msec= --property= --raw --passthrough
                --file-format= --list-file-formats';
    _init_completion -n = || return;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        --device=*)
            cur=${cur#*=};
            comps=$(__sinks);
            comps+=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --rate=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W '32000 44100 48000 9600 192000' -- "$cur"))
        ;;
        --file-format=*)
            cur=${cur#*=};
            comps=$(_pacat_file_formats);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --*=*)

        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
        *)
            _filedir
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
        -d)
            comps=$(__sinks);
            comps+=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
    esac
}
_pacat_file_formats () 
{ 
    while IFS='	' read name _; do
        printf "%s\n" "$name";
    done < <(pacat --list-file-formats 2> /dev/null)
}
_pacmd () 
{ 
    local cur prev words cword preprev command;
    local comps;
    local flags='-h --help --version';
    local commands=(exit help list-modules list-sinks list-sources list-clients list-samples list-sink-inputs list-source-outputs stat info load-module unload-module describe-module set-sink-volume set-source-volume set-sink-input-volume set-source-output-volume set-sink-mute set-source-mut set-sink-input-mute set-source-output-mute update-sink-proplist update-source-proplist update-sink-input-proplist update-source-output-proplist set-default-sink set-default-source kill-client kill-sink-input kill-source-output play-sample remove-sample load-sample load-sample-lazy load-sample-dir-lazy play-file dump move-sink-input move-source-output suspend-sink suspend-source suspend set-card-profile set-sink-port set-source-port set-port-latency-offset set-log-target set-log-level set-log-meta set-log-time set-log-backtrace);
    _init_completion -n = || return;
    preprev=${words[$cword-2]};
    for word in "${COMP_WORDS[@]}";
    do
        if in_array "$word" "${commands[@]}"; then
            command=$word;
            break;
        fi;
    done;
    case $preprev in 
        play-sample | play-file)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        load-sample*)
            _filedir
        ;;
        move-sink-input)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-source-output)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card-profile)
            comps=$(__profiles);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*port*)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-mute)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        set-sink-formats)

        ;;
    esac;
    case $prev in 
        list-*)

        ;;
        describe-module | load-module)
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        unload-module)
            comps=$(__loaded_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        load-sample-dir-lazy)
            _filedir -d
        ;;
        play-file)
            _filedir
        ;;
        *sink-input*)
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source-output*)
            comps=$(__source_outputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink*)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source*)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-port-*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-log-target)
            COMPREPLY=($(compgen -W 'auto syslog stderr file: newfile:' -- "$cur"))
        ;;
        set-log-level)
            COMPREPLY=($(compgen -W '{0..4}' -- "$cur"))
        ;;
        set-log-meta | set-log-time | suspend)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
    esac;
    case $cur in 
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"))
        ;;
        suspend)
            COMPREPLY=($(compgen -W 'suspend suspend-sink suspend-source' -- "$cur"))
        ;;
        load-sample)
            COMPREPLY=($(compgen -W 'load-sample load-sample-lazy load-sample-dir-lazy' -- "$cur"))
        ;;
        *)
            [[ -z $command ]] && COMPREPLY=($(compgen -W '${commands[*]}' -- "$cur"))
        ;;
    esac
}
_pactl () 
{ 
    local cur prev words cword preprev command;
    local comps;
    local flags='-h --help --version -s --server= --client-name=';
    local list_types='short sinks sources sink-inputs source outputs cards
                    modules samples clients';
    local commands=(stat info list exit upload-sample play-sample remove-sample load-module unload-module move-sink-input move-source-output suspend-sink suspend-source set-card-profile set-sink-port set-source-port set-sink-volume set-source-volume set-sink-input-volume set-source-output-volume set-sink-mute set-source-mute set-sink-input-mute set-source-output-mute set-sink-formats set-port-latency-offset subscribe help);
    _init_completion -n = || return;
    preprev=${words[$cword-2]};
    for word in "${COMP_WORDS[@]}";
    do
        if in_array "$word" "${commands[@]}"; then
            command=$word;
            break;
        fi;
    done;
    case $preprev in 
        list)
            COMPREPLY=($(compgen -W 'short' -- "$cur"))
        ;;
        play-sample)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-sink-input)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-source-output)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card-profile)
            comps=$(__profiles);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-port)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-mute)
            COMPREPLY=($(compgen -W 'true false toggle' -- "$cur"))
        ;;
        set-sink-formats)

        ;;
        set-port-*)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --server)
            compopt +o nospace;
            _known_hosts_real "$cur"
        ;;
    esac;
    [[ -n $COMPREPLY ]] && return 0;
    case $prev in 
        list)
            COMPREPLY=($(compgen -W '${list_types[*]}' -- "$cur"))
        ;;
        stat)
            COMPREPLY=($(compgen -W 'short' -- "$cur"))
        ;;
        upload-sample)
            _filedir
        ;;
        play-sample)

        ;;
        remove-sample)

        ;;
        load-module)
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        unload-module)
            comps=$(__loaded_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink-input*)
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source-output*)
            comps=$(__source_outputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-sink-formats)
            comps=$(__sinks_idx);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink*)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source*)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-port*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        -s)
            _known_hosts_real "$cur"
        ;;
    esac;
    [[ -n $COMPREPLY ]] && return 0;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
        *)
            [[ -z $command ]] && COMPREPLY=($(compgen -W '${commands[*]}' -- "$cur"))
        ;;
    esac
}
_padsp () 
{ 
    local cur prev;
    local flags='-h -s -n -m -M -S -D -d';
    _get_comp_words_by_ref cur prev;
    case $cur in 
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"))
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
    esac
}
_parse_help () 
{ 
    eval local cmd=$( quote "$1" );
    local line;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---help} 2>&1
            ;;
        esac
    } | while read -r line; do
        [[ $line == *([ '	'])-* ]] || continue;
        while [[ $line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+\]? ]]; do
            line=${line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
        done;
        __parse_options "${line// or /, }";
    done
}
_parse_usage () 
{ 
    eval local cmd=$( quote "$1" );
    local line match option i char;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---usage} 2>&1
            ;;
        esac
    } | while read -r line; do
        while [[ $line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
            match=${BASH_REMATCH[0]};
            option=${BASH_REMATCH[1]};
            case $option in 
                -?(\[)+([a-zA-Z0-9?]))
                    for ((i=1; i < ${#option}; i++ ))
                    do
                        char=${option:i:1};
                        [[ $char != '[' ]] && printf '%s\n' -$char;
                    done
                ;;
                *)
                    __parse_options "$option"
                ;;
            esac;
            line=${line#*"$match"};
        done;
    done
}
_pasuspender () 
{ 
    local cur prev;
    local flags='-h --help --version -s --server=';
    _init_completion -n = || return;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
    esac
}
_pci_ids () 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur" ))
}
_perl () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    local prefix="" temp optPrefix optSuffix;
    if [[ "$cur" == -?* ]]; then
        temp=$cur;
        prev=${temp:0:2};
        cur=${temp:2};
        optPrefix=-P$prev;
        optSuffix=-S/;
        prefix=$prev;
    fi;
    case $prev in 
        -D | -e | -E | -i | -F | -l)
            return 0
        ;;
        -I | -x)
            local IFS='
';
            compopt -o filenames;
            COMPREPLY=($( compgen -d $optPrefix $optSuffix -- "$cur" ));
            return 0
        ;;
        -m | -M)
            temp="${cur#-}";
            prefix+="${cur%$temp}";
            cur="$temp";
            _perlmodules $1;
            return 0
        ;;
        -V)
            if [[ $cur == :* ]]; then
                temp="${cur##+(:)}";
                prefix+="${cur%$temp}";
                local IFS='
';
                COMPREPLY=($( compgen -P "$prefix" -W                     '$( $1 -MConfig -e "print join \"\\n\",
                        keys %Config::Config" 2>/dev/null )' -- "$temp" ));
                __ltrim_colon_completions "$prefix$temp";
            fi;
            return 0
        ;;
        -d | -dt)
            if [[ $cur == :* ]]; then
                temp="${cur#:}";
                prefix="$prefix${cur%$temp}";
                cur="Devel::$temp";
                _perlmodules $1;
            fi;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-C -s -T -u -U -W -X -h -v -V -c -w -d -D -p
            -n -a -F -l -0 -I -m -M -P -S -x -i -e' -- "$cur" ));
    else
        _filedir;
    fi
}
_perldoc () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    local prefix="" temp;
    if [[ "$cur" == -?* ]]; then
        temp=$cur;
        prev=${temp:0:2};
        cur=${temp:2};
        prefix=$prev;
    fi;
    local perl="${1%doc}";
    [[ $perl == $1 ]] || ! type $perl &> /dev/null && perl=;
    case $prev in 
        -h | -V | -n | -o | -M | -w | -L)
            return 0
        ;;
        -d)
            _filedir;
            return 0
        ;;
        -f)
            _perlfunctions $perl;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '$( _parse_help "$1" -h )' -- "$cur" ));
    else
        if [[ "$cur" != @(*/|[.~])* ]]; then
            _perlmodules $perl;
            if [[ $cur == p* ]]; then
                COMPREPLY+=($( compgen -W                     '$( PERLDOC_PAGER=/bin/cat "$1" -u perl |  \
                     sed -ne "/perl.*Perl overview/,/perlwin32/p" | \
                     awk "\$NF=2 && \$1 ~ /^perl/ { print \$1 }" )'                     -- "$cur" ));
            fi;
        fi;
        _filedir 'p@(l|m|od)';
    fi
}
_perlfunctions () 
{ 
    COMPREPLY=($( compgen -P "$prefix" -W         "$( ${1:-perl} ${BASH_SOURCE[0]%/*}/../helpers/perl functions $cur )"         -- "$cur" ))
}
_perlmodules () 
{ 
    COMPREPLY=($( compgen -P "$prefix" -W         "$( ${1:-perl} ${BASH_SOURCE[0]%/*}/../helpers/perl modules $cur )"         -- "$cur" ));
    __ltrim_colon_completions "$prefix$cur"
}
_pgids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pgid= )' -- "$cur" ))
}
_pids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pid= )' -- "$cur" ))
}
_pnames () 
{ 
    COMPREPLY=($( compgen -X '<defunct>' -W '$( command ps axo command= | \
        sed -e "s/ .*//" -e "s:.*/::" -e "s/:$//" -e "s/^[[(-]//" \
            -e "s/[])]$//" | sort -u )' -- "$cur" ))
}
_poff () 
{ 
    local prev cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    prev=${COMP_WORDS[COMP_CWORD-1]};
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '-r -d -c -a -h -v' -- $cur));
        return 0;
    fi;
    if [ $COMP_CWORD -eq 1 ] && [[ "$cur" != -* ]] || [[ "$prev" == -* ]]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
_pon () 
{ 
    local cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
_pulseaudio () 
{ 
    local cur prev words cword;
    local flags='-h --help --version --dump-conf --dump-resample-methods --cleanup-shm
                --start -k --kill --check --system= -D --daemonize= --fail= --high-priority=
                --realtime= --disallow-module-loading= --disallow-exit= --exit-idle-time=
                --scache-idle-time= --log-level= -v --log-target= --log-meta= --log-time=
                --log-backtrace= -p --dl-search-path= --resample-method= --use-pit-file=
                --no-cpu-limit= --disable-shm= -L --load= -F --file= -C -n';
    _init_completion -n = || return;
    case $cur in 
        --system=* | --daemonize=* | --fail=* | --high-priority=* | --realtime=* | --disallow-*=* | --log-meta=* | --log-time=* | --use-pid-file=* | --no-cpu-limit=* | --disable-shm=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        --log-target=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W 'auto syslog stderr file: newfile:' -- "$cur"))
        ;;
        --log-level=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W '{0..4}' -- "$cur"))
        ;;
        --dl-search-path=*)
            cur=${cur#*=};
            _filedir -d
        ;;
        --file=*)
            cur=${cur#*=};
            _filedir
        ;;
        --resample-method=*)
            cur=${cur#*=};
            comps=$(__resample_methods);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --load=*)
            cur=${cur#*=};
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --*=*)

        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
    esac;
    case $prev in 
        -D)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        -p)
            _filedir -d
        ;;
        -F)
            _filedir
        ;;
        -L)
            cur=${cur#*=};
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
    esac
}
_python () 
{ 
    local cur prev words cword;
    _init_completion || return;
    case $prev in 
        -'?' | -h | --help | -V | --version | -c)
            return 0
        ;;
        -m)
            _python_modules "$1";
            return 0
        ;;
        -Q)
            COMPREPLY=($( compgen -W "old new warn warnall" -- "$cur" ));
            return 0
        ;;
        -W)
            COMPREPLY=($( compgen -W "ignore default all module once error"                 -- "$cur" ));
            return 0
        ;;
        !(?(*/)python*([0-9.])|-?))
            [[ $cword -lt 2 || ${words[cword-2]} != -@(Q|W) ]] && _filedir
        ;;
    esac;
    local i;
    for ((i=0; i < ${#words[@]}-1; i++ ))
    do
        if [[ ${words[i]} == -c ]]; then
            _filedir;
        fi;
    done;
    if [[ "$cur" != -* ]]; then
        _filedir 'py?([co])';
    else
        COMPREPLY=($( compgen -W '$( _parse_help "$1" -h )' -- "$cur" ));
    fi;
    return 0
}
_python_modules () 
{ 
    COMPREPLY+=($( compgen -W "$( ${1:-python} -c 'import pkgutil
for mod in pkgutil.iter_modules(): print(mod[1])' )" 2>/dev/null -- "$cur" ))
}
_quote_readline_by_ref () 
{ 
    if [ -z "$1" ]; then
        printf -v $2 %s "$1";
    else
        if [[ $1 == \'* ]]; then
            printf -v $2 %s "${1:1}";
        else
            if [[ $1 == \~* ]]; then
                printf -v $2 \~%q "${1:1}";
            else
                printf -v $2 %q "$1";
            fi;
        fi;
    fi;
    [[ ${!2} == *\\* ]] && printf -v $2 %s "${1//\\\\/\\}";
    [[ ${!2} == \$* ]] && eval $2=${!2}
}
_realcommand () 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p greadlink > /dev/null; then
                greadlink -f "$(type -P "$1")";
            else
                if type -p readlink > /dev/null; then
                    readlink -f "$(type -P "$1")";
                else
                    type -P "$1";
                fi;
            fi;
        fi
    }
}
_rl_enabled () 
{ 
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}
_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command
}
_service () 
{ 
    local cur prev words cword;
    _init_completion || return;
    [[ $cword -gt 2 ]] && return 0;
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
        _services;
        [[ -e /etc/mandrake-release ]] && _xinetd_services;
    else
        local sysvdirs;
        _sysvdirs;
        COMPREPLY=($( compgen -W '`sed -e "y/|/ /" \
            -ne "s/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p" \
            ${sysvdirs[0]}/${prev##*/} 2>/dev/null` start stop' -- "$cur" ));
    fi
}
_services () 
{ 
    local sysvdirs;
    _sysvdirs;
    local restore_nullglob=$(shopt -p nullglob);
    shopt -s nullglob;
    COMPREPLY=($( printf '%s\n' ${sysvdirs[0]}/!($_backup_glob|functions) ));
    $restore_nullglob;
    COMPREPLY+=($( systemctl list-units --full --all 2>/dev/null |         awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]#${sysvdirs[0]}/}' -- "$cur" ))
}
_shells () 
{ 
    local shell rest;
    while read -r shell rest; do
        [[ $shell == /* && $shell == "$cur"* ]] && COMPREPLY+=($shell);
    done 2> /dev/null < /etc/shells
}
_signals () 
{ 
    local -a sigs=($( compgen -P "$1" -A signal "SIG${cur#$1}" ));
    COMPREPLY+=("${sigs[@]/#${1}SIG/${1}}")
}
_split_longopt () 
{ 
    if [[ "$cur" == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_sysvdirs () 
{ 
    sysvdirs=();
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d)
}
_terms () 
{ 
    COMPREPLY+=($( compgen -W         "$( sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap             2>/dev/null )" -- "$cur" ));
    COMPREPLY+=($( compgen -W "$( { toe -a 2>/dev/null || toe 2>/dev/null; }         | awk '{ print $1 }' | sort -u )" -- "$cur" ))
}
_tilde () 
{ 
    local result=0;
    if [[ $1 == \~* && $1 != */* ]]; then
        COMPREPLY=($( compgen -P '~' -u "${1#\~}" ));
        result=${#COMPREPLY[@]};
        [[ $result -gt 0 ]] && compopt -o filenames 2> /dev/null;
    fi;
    return $result
}
_ufw () 
{ 
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W "$(_ufw_commands)" $cur ));
    else
        if [ $COMP_CWORD -eq 2 ]; then
            case "$prev" in 
                app)
                    COMPREPLY=($( compgen -W "$(_ufw_app_commands)" $cur ))
                ;;
                status)
                    COMPREPLY=($( compgen -W "$(_ufw_status_commands)" $cur ))
                ;;
                delete)
                    COMPREPLY=($( compgen -W "$(_ufw_rule_commands)" $cur ))
                ;;
                logging)
                    COMPREPLY=($( compgen -W "$(_ufw_logging_commands)" $cur ))
                ;;
                show)
                    COMPREPLY=($( compgen -W "$(_ufw_show_commands)" $cur ))
                ;;
                default)
                    COMPREPLY=($( compgen -W "$(_ufw_default_commands)" $cur ))
                ;;
            esac;
        fi;
    fi
}
_ufw_app_commands () 
{ 
    ufw --help | sed -e '1,/^Application profile commands:/d' -e '/^ [^ ]/!d' -e 's/[ \t]\+app[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g'
}
_ufw_commands () 
{ 
    commands=$(ufw --help | sed -e '1,/^Commands:/d' -e '/^Application profile commands:/Q' -e 's/^[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g' -e 's/|/ /g' | uniq);
    echo "$commands app"
}
_ufw_default_commands () 
{ 
    echo "allow deny reject"
}
_ufw_logging_commands () 
{ 
    echo "off on low medium high full"
}
_ufw_rule_commands () 
{ 
    echo "`_ufw_default_commands` limit"
}
_ufw_show_commands () 
{ 
    echo "raw"
}
_ufw_status_commands () 
{ 
    echo "numbered verbose"
}
_uids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent passwd | cut -d: -f3 )' -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/passwd )' -- "$cur" ));
        fi;
    fi
}
_update_initramfs () 
{ 
    local cur prev valid_options;
    cur=$(_get_cword);
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ "$prev" == '-k' ]]; then
        _kernel_versions;
        COMPREPLY=($( compgen -W '${COMPREPLY[@]} all' -- "$cur" ));
        return;
    fi;
    valid_options=$( update-initramfs -h 2>&1 | 		sed -e '/^ -/!d;s/^ \(-\w\+\).*/\1/' );
    COMPREPLY=($( compgen -W "$valid_options" -- $cur ))
}
_upstart_events () 
{ 
    ( cd /etc/init && egrep --color=auto '^[[:space:]]*emits ' *.conf | cut -d: -f2- | sed 's/^[[:space:]]*emits //g' | tr ' ' '\n' | awk '{print $NF}' | grep --color=auto -v ^$ | sort -u )
}
_upstart_initctl () 
{ 
    _get_comp_words_by_ref cur prev;
    COMPREPLY=();
    case "$prev" in 
        start)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_startable_jobs)" -- ${cur}));
            return 0
        ;;
        stop)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_stoppable_jobs)" -- ${cur}));
            return 0
        ;;
        emit)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_events)" -- ${cur}));
            return 0
        ;;
        -i | --ignore-events)
            for cmd in check-config;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
                    return 0;
                fi;
            done
        ;;
        -e | --enumerate)
            for cmd in show-config;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
                    return 0;
                fi;
            done
        ;;
        reload | restart)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_stoppable_jobs)" -- ${cur}));
            return 0
        ;;
        status)
            COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        check-config)
            COMPREPLY=($(compgen -W "-w --warn -i --ignore-events= $(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        show-config)
            COMPREPLY=($(compgen -W "-e --enumerate $(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        -n | --no-wait)
            for cmd in start stop restart emit;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    case "$cmd" in 
                        start)
                            COMPREPLY=($(compgen -W "$(_upstart_startable_jobs)" -- ${cur}))
                        ;;
                        stop)
                            COMPREPLY=($(compgen -W "$(_upstart_stoppable_jobs)" -- ${cur}))
                        ;;
                        restart)
                            COMPREPLY=($(compgen -W "$(_upstart_stoppable_jobs)" -- ${cur}))
                        ;;
                        emit)
                            COMPREPLY=($(compgen -W "$(_upstart_events)" -- ${cur}))
                        ;;
                    esac;
                    return 0;
                fi;
            done
        ;;
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=";
    cmds=$(initctl help|grep "^  [^ ]"|awk '{print $1}');
    COMPREPLY=($(compgen -W "${opts} ${cmds}" -- ${cur}))
}
_upstart_jobs () 
{ 
    initctl list | awk '{print $1}' | sort -u
}
_upstart_reload () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_restart () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_start () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_startable_jobs)" -- ${cur}));
    return 0
}
_upstart_startable_jobs () 
{ 
    initctl list | cut -d\, -f1 | awk '$2 == "stop/waiting" {print $1}'
}
_upstart_status () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q -d --detail -e --enumerate --quiet -v --verbose --session --system --dest=";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_jobs)" -- ${cur}));
    return 0
}
_upstart_stop () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_stoppable_jobs () 
{ 
    initctl list | cut -d\, -f1 | awk '$2 == "start/running" {print $1}'
}
_upvar () 
{ 
    if unset -v "$1"; then
        if (( $# == 2 )); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\${@:2}\"\);
        fi;
    fi
}
_upvars () 
{ 
    if ! (( $# )); then
        echo "${FUNCNAME[0]}: usage: ${FUNCNAME[0]} [-v varname" "value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (( $# )); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash: ${FUNCNAME[0]}: \`$1': missing" "number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &> /dev/null || { 
                    echo "bash:" "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && shift $((${1#-a} + 2)) || { 
                    echo "bash: ${FUNCNAME[0]}:" "\`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                    echo "bash: ${FUNCNAME[0]}: $1: missing" "argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_usb_ids () 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lsusb | awk '{print $6}' )" -- "$cur" ))
}
_user_at_host () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_usergroup () 
{ 
    if [[ $cur = *\\\\* || $cur = *:*:* ]]; then
        return;
    else
        if [[ $cur = *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\};
            local mycur="${cur#*[:]}";
            if [[ $1 == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($( compgen -g -- "$mycur" ));
            fi;
            COMPREPLY=($( compgen -P "$prefix" -W "${COMPREPLY[@]}" ));
        else
            if [[ $cur = *:* ]]; then
                local mycur="${cur#*:}";
                if [[ $1 == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -g -- "$mycur" ));
                fi;
            else
                if [[ $1 == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -u -- "$cur" ));
                fi;
            fi;
        fi;
    fi
}
_userland () 
{ 
    local userland=$( uname -s );
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ $userland == $1 ]]
}
_variables () 
{ 
    if [[ $cur =~ ^(\$\{?)([A-Za-z0-9_]*)$ ]]; then
        [[ $cur == *{* ]] && local suffix=} || local suffix=;
        COMPREPLY+=($( compgen -P ${BASH_REMATCH[1]} -S "$suffix" -v --             "${BASH_REMATCH[2]}" ));
        return 0;
    fi;
    return 1
}
_xfunc () 
{ 
    set -- "$@";
    local srcfile=$1;
    shift;
    declare -F $1 &> /dev/null || { 
        local compdir=./completions;
        [[ $BASH_SOURCE == */* ]] && compdir="${BASH_SOURCE%/*}/completions";
        . "$compdir/$srcfile"
    };
    "$@"
}
_xinetd_services () 
{ 
    local xinetddir=/etc/xinetd.d;
    if [[ -d $xinetddir ]]; then
        local restore_nullglob=$(shopt -p nullglob);
        shopt -s nullglob;
        local -a svcs=($( printf '%s\n' $xinetddir/!($_backup_glob) ));
        $restore_nullglob;
        COMPREPLY+=($( compgen -W '${svcs[@]#$xinetddir/}' -- "$cur" ));
    fi
}
command_not_found_handle () 
{ 
    if [ -x /usr/lib/command-not-found ]; then
        /usr/lib/command-not-found -- "$1";
        return $?;
    else
        if [ -x /usr/share/command-not-found/command-not-found ]; then
            /usr/share/command-not-found/command-not-found -- "$1";
            return $?;
        else
            printf "%s: command not found\n" "$1" 1>&2;
            return 127;
        fi;
    fi
}
dequote () 
{ 
    eval printf %s "$1" 2> /dev/null
}
in_array () 
{ 
    local i;
    for i in "${@:2}";
    do
        [[ $1 = "$i" ]] && return;
    done
}
quote () 
{ 
    local quoted=${1//\'/\'\\\'\'};
    printf "'%s'" "$quoted"
}
quote_readline () 
{ 
    local quoted;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
